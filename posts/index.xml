<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>All Posts - 恩佐思維</title>
        <link>https://enzochang.com/posts/</link>
        <description>All Posts | 恩佐思維</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>enzoapu@gmail.com (Enzo Chang)</managingEditor>
            <webMaster>enzoapu@gmail.com (Enzo Chang)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 27 Feb 2022 22:00:00 &#43;0800</lastBuildDate><atom:link href="https://enzochang.com/posts/" rel="self" type="application/rss+xml" /><item>
    <title>RabbitMQ 介紹</title>
    <link>https://enzochang.com/rabbitmq/</link>
    <pubDate>Sun, 27 Feb 2022 22:00:00 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://enzochang.com/rabbitmq/</guid>
    <description><![CDATA[RabbitMQ 介紹 前言 RabbitMQ 是使用廣泛的輕量級開源工具，支持多種訊息傳遞協定(e.g. AMQP 0-9-1) 有以下優勢：
 RabbitMQ 容易在本地端和雲端部署，滿足大規模(分散式)、高可用性的需求。 RabbitMQ 為大多數流行的程式語言提供了多樣的開發套件包。(Python, Java, Ruby, PHP, C#, JS, Go, etc.) RabbitMQ 提供了一個 Web 使用者介面來管理權限並監控各種狀態、指標。  RabbitMQ 架構 圖片
看完上一篇我們已經知道 Message Queue 架構中的三個角色，在 RabbitMQ 中也延用相同概念：
 Producer 是發送訊息的應用程式 Queue 是儲存訊息的緩衝區 Consumer 是接收訊息的應用程式  不過在 RabbitMQ 中，根據不同模式會在 Producer 與 Queue 之間加上一層 Exchange。
 Exchange 的工作非很簡單，透過綁定(binding)與 Queue 連結，負責接收來自 Producer 的訊息，然後將訊息推送給 Queue。 透過定義 Exchange 的類型(type)來判斷要如何處理收到的訊息，是要推送給哪個特定 Queue？還是要推送給多個 Queue？或是應該被丟棄？ Exchange 的類型(type)有分為 direct, topic, fanout &amp; headers，文章下個段落介紹不同模式時會探討差別。  常見的設計模式 根據 RabbitMQ Tutorials 的範例，展示了六種常見的模式，以下簡單做介紹（Python 範例程式碼附在標題後方連結）]]></description>
</item><item>
    <title>訊息佇列 Message Queue(MQ) 介紹</title>
    <link>https://enzochang.com/message-queue/</link>
    <pubDate>Sun, 27 Feb 2022 20:00:00 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://enzochang.com/message-queue/</guid>
    <description><![CDATA[訊息佇列 Message Queue(MQ) 介紹 前言 這陣子在開發一個 ML Product，為了要把系統架構解耦，改成異步分散式處理，因而接觸到訊息佇列(Message Queue)，作為兩個子系統（商品資料爬蟲 &amp; 圖片/文字向量轉換）的通信中間層，這篇文章將分享我在架設 RabbitMQ 與使用 Python 實作上的學習。
什麼是 Message Queue(MQ)？ Message Queue - singleMessage Queue - single
" Message Queue - single 
Message Queue(MQ)是一種訊息傳遞仲介，架構中擁有三個角色，分別為 Producer、Broker 及 Consumer，提供不同程序(process)或不同系統(system)的非同步(asynchronous)溝通。
什麼是非同步呢？  一般常見的 HTTP API 就屬於同步式方法，發送方(sender)發出請求(request)等待接收方(receiver)處理完回應(response)，等待過程連結不能斷開去做其他事。   由於先進先出(FIFO)的特性，發送方(producer)只要把訊息/任務往 MQ(broker) 裡面丟，接收方(consumer)就能夠依序從 MQ(broker)中取出訊息/任務，使雙方能夠獨立運作。
使用 Message Queue 有什麼好處？ 任務緩衝 短時間內收到大量請求可能會導致系統過載，特別是 CPU / GPU 運算吃重(heavy computing)的情況，這時候 MQ 就發揮了緩衝的功能，Producer 不需等待地發送任務；Consumer 依自己的資源或算力取出適量的任務，處理完再繼續拿。
暫存容錯 若 Consumer 意外關閉，未處理完的訊息/任務還會存在 MQ 內，並不會丟失，只要再把 Consumer 重啟，又可以接續處理。]]></description>
</item><item>
    <title>CI/CD 介紹 - 基礎概念與導入準備</title>
    <link>https://enzochang.com/cicd-intro/</link>
    <pubDate>Sun, 13 Feb 2022 20:00:00 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://enzochang.com/cicd-intro/</guid>
    <description><![CDATA[CI/CD Introduction - 概念與導入前準備 前言 自從去年初啟動“敏捷”(Scrum)導入，幾乎都在適應(迭代)各種流程、方法和工具，工程實踐方面的單元測試和 CI/CD 推行計畫卻一直往後延。如今，因應團隊一個大型系統要進行前後端分離重構，加上大家對於容器化技術越來越熟悉，同時又有優秀的新夥伴加入，可謂是天時地利人和啊，我們終於要開始在“開發”上實踐敏捷，啟動 CI/CD 導入！
這此之前我對 CI/CD 的理解幾乎是一片空白，因此想利用這篇文章，記錄過程中的學習心得與知識整理。首先將介紹「什麼是 CI/CD？」、「為什麼要 CI/CD？」、「CI/CD 如何做？」以及「常見的 CI/CD 工具」，您可以透過右側選單快速跳轉至有興趣之章節。內容會比較初淺，請小心服用。 歡迎給予任何反饋和指正～
什麼是 CI/CD？ 敏捷式軟體開發生命週期中，從開發、測試到部署是一系列持續迭代的過程，CI/CD 指的是持續整合和持續交付或持續部署的組合實踐。CI/CD通過在應用程式的構建、測試和部署中實施自動化，在開發和運營團隊之間架起了橋梁。
CI 持續整合 (Continuous Integration, CI) 每當開發人員 push 程式碼變更到 remote repository 時，觸發自動化 build 和 test 的程序，確保這次的變更是符合規範且通過所有測試案例的，減少有問題的程式碼影響到生產環境的機會。
CD 持續交付 / 持續部署 (Continuous Delivery / Continuous Deployment) 完成 Build 和 Test 的下一步就是程式碼部署啦，而 Continuous Delivery 和 Continuous Deployment 的差別就是人為手動部署和自動化部署而已。
CI/CD Workflow 從上面這張流程圖的可以看出 CI/CD 主要的工作流：(1)當專案程式碼提交 (commit → push / merge)；(2)進入 CI Pipeline，建立一個測試環境，跑過所有單元測試+整合測試、程式碼規範檢查；(3)進入 CD Pipeline，完成程式碼部署。]]></description>
</item></channel>
</rss>
