<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>rabbitmq - Tag - 恩佐思維</title>
        <link>https://enzochang.com/tags/rabbitmq/</link>
        <description>rabbitmq - Tag - 恩佐思維</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>enzoapu@gmail.com (Enzo Chang)</managingEditor>
            <webMaster>enzoapu@gmail.com (Enzo Chang)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 27 Feb 2022 22:00:00 &#43;0800</lastBuildDate><atom:link href="https://enzochang.com/tags/rabbitmq/" rel="self" type="application/rss+xml" /><item>
    <title>RabbitMQ 介紹</title>
    <link>https://enzochang.com/rabbitmq/</link>
    <pubDate>Sun, 27 Feb 2022 22:00:00 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://enzochang.com/rabbitmq/</guid>
    <description><![CDATA[RabbitMQ 介紹 前言 RabbitMQ 是使用廣泛的輕量級開源工具，支持多種訊息傳遞協定(e.g. AMQP 0-9-1) 有以下優勢：
 RabbitMQ 容易在本地端和雲端部署，滿足大規模(分散式)、高可用性的需求。 RabbitMQ 為大多數流行的程式語言提供了多樣的開發套件包。(Python, Java, Ruby, PHP, C#, JS, Go, etc.) RabbitMQ 提供了一個 Web 使用者介面來管理權限並監控各種狀態、指標。  RabbitMQ 架構 圖片
看完上一篇我們已經知道 Message Queue 架構中的三個角色，在 RabbitMQ 中也延用相同概念：
 Producer 是發送訊息的應用程式 Queue 是儲存訊息的緩衝區 Consumer 是接收訊息的應用程式  不過在 RabbitMQ 中，根據不同模式會在 Producer 與 Queue 之間加上一層 Exchange。
 Exchange 的工作非很簡單，透過綁定(binding)與 Queue 連結，負責接收來自 Producer 的訊息，然後將訊息推送給 Queue。 透過定義 Exchange 的類型(type)來判斷要如何處理收到的訊息，是要推送給哪個特定 Queue？還是要推送給多個 Queue？或是應該被丟棄？ Exchange 的類型(type)有分為 direct, topic, fanout &amp; headers，文章下個段落介紹不同模式時會探討差別。  常見的設計模式 根據 RabbitMQ Tutorials 的範例，展示了六種常見的模式，以下簡單做介紹（Python 範例程式碼附在標題後方連結）]]></description>
</item></channel>
</rss>
