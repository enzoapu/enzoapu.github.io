[{"categories":["Data Engineering"],"content":"前言 RabbitMQ 是使用廣泛的輕量級開源工具，支持多種訊息傳遞協定(e.g. AMQP 0-9-1) 有以下優勢： RabbitMQ 容易在本地端和雲端部署，滿足大規模(分散式)、高可用性的需求。 RabbitMQ 為大多數流行的程式語言提供了多樣的開發套件包。(Python, Java, Ruby, PHP, C#, JS, Go, etc.) RabbitMQ 提供了一個 Web 使用者介面來管理權限並監控各種狀態、指標。 ","date":"2022-03-01","objectID":"/rabbitmq-python/:1:0","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 03 - RabbitMQ x Python 實作範例","uri":"/rabbitmq-python/"},{"categories":["Data Engineering"],"content":"前言 RabbitMQ 是使用廣泛的輕量級開源工具，支持多種訊息傳遞協定(e.g. AMQP 0-9-1) 有以下優勢： RabbitMQ 容易在本地端和雲端部署，滿足大規模(分散式)、高可用性的需求。 RabbitMQ 為大多數流行的程式語言提供了多樣的開發套件包。(Python, Java, Ruby, PHP, C#, JS, Go, etc.) RabbitMQ 提供了一個 Web 使用者介面來管理權限並監控各種狀態、指標。 ","date":"2022-02-28","objectID":"/rabbitmq-intro/:1:0","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 設計模式與管理介面","uri":"/rabbitmq-intro/"},{"categories":["Data Engineering"],"content":"RabbitMQ 架構 圖片 看完上一篇我們已經知道 Message Queue 架構中的三個角色，在 RabbitMQ 中也延用相同概念： Producer 是發送訊息的應用程式 Queue 是儲存訊息的緩衝區 Consumer 是接收訊息的應用程式 不過在 RabbitMQ 中，根據不同模式會在 Producer 與 Queue 之間加上一層 Exchange。 Exchange 的工作非很簡單，透過綁定(binding)與 Queue 連結，負責接收來自 Producer 的訊息，然後將訊息推送給 Queue。 透過定義 Exchange 的類型(type)來判斷要如何處理收到的訊息，是要推送給哪個特定 Queue？還是要推送給多個 Queue？或是應該被丟棄？ Exchange 的類型(type)有分為 direct, topic, fanout \u0026 headers，文章下個段落介紹不同模式時會探討差別。 -- ","date":"2022-02-28","objectID":"/rabbitmq-intro/:2:0","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 設計模式與管理介面","uri":"/rabbitmq-intro/"},{"categories":["Data Engineering"],"content":"常見的設計模式 根據 RabbitMQ Tutorials 的範例，展示了六種常見的模式，以下簡單做介紹（Python 範例程式碼附在標題後方連結） ","date":"2022-02-28","objectID":"/rabbitmq-intro/:3:0","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 設計模式與管理介面","uri":"/rabbitmq-intro/"},{"categories":["Data Engineering"],"content":"1. Simple 模式 The simplest thing that does something (sample code) Simple\" Simple 最基本的一種模式，只有一個 Queue(定義 Queue 的名稱)，Producer 直接將訊息傳進這個 Queue(hello)，也只有一個 Consumer 從這個 Queue(hello) 取出訊息。 ","date":"2022-02-28","objectID":"/rabbitmq-intro/:3:1","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 設計模式與管理介面","uri":"/rabbitmq-intro/"},{"categories":["Data Engineering"],"content":"2. Worker 模式 Distributing tasks among workers (sample code) Worker\" Worker 相比 Simple，Worker 模式會有兩個以上的 Consumer(Worker)，從同一個 Queue 取出訊息，加速訊息處理(消化)速度。因此只要連接同一個 Queue，就可以在多台機器上 Consumer 平行處理。 Consumer 彼此間不會取得相同的訊息，可以透過 prefetch_count 參數，控制每個 Consumer(Worker) 一次取出的訊息量，例如：P 將 1 ~ 10 依序傳進 Queue，prefetch_count = 1 ，C1 依序取出 1、3、5、7、9（共五次），C2 依序取出 2、4、6、8、10（共五次）；prefetch_count = 2 ，C1 依序取出 1, 2、5, 6、9, 10（共三次），C2 依序取出 3, 4、7, 8（共兩次）。 ","date":"2022-02-28","objectID":"/rabbitmq-intro/:3:2","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 設計模式與管理介面","uri":"/rabbitmq-intro/"},{"categories":["Data Engineering"],"content":"3. Publish/Subscribe 模式 Sending messages to many consumers at once (sample code) Publish/Subscribe\" Publish/Subscribe Publish/Subscribe 模式顧名思義屬，就像你訂閱某個 YT 頻道，當頻道創作者發佈了新影片，連同你的所有訂閱者都會收到通知。 Producer 不會將訊息直接傳進 Queue，而是交給 Exchange(type=fanout)，由於 fanout 的特性，Exchange 會把訊息廣播給所有綁定的 Queue，每個 Consumer 就會接收到相同的訊息。因此當有另外的系統需要同步接收訊息，只需增加一組 Queue + Producer，綁定這個 Exchange 即可。 ","date":"2022-02-28","objectID":"/rabbitmq-intro/:3:3","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 設計模式與管理介面","uri":"/rabbitmq-intro/"},{"categories":["Data Engineering"],"content":"4. Routing 模式 Receiving messages selectively (sample code) Routing\" Routing Routing 模式同樣有一層 Exchange(type=direct)，但不同的是 direct 的特性，Exchange 與 Queue 的綁定(binding)還會帶上 routing key，Producer 傳送訊息到 Exchange 時也會帶上 routing key 這個參數。因此可以達到選擇性訊息分流，不同 Consumer 只需要接受到特定 routing 的訊息。 Logging system\" Logging system 上圖為一個日誌系統(logging system)的範例，使用兩組 Queue，Q1 只有綁定一個 routing key(error)，因此負責寫檔(log file)的 C1 只會接收 error log messages，可節省硬碟(disk)空間。Q2 則是綁定多個 routing key(info, warning \u0026 error)，負責打印到控制台(console)的 C2 仍然可輸出所有層級(level)的 log messages。 ","date":"2022-02-28","objectID":"/rabbitmq-intro/:3:4","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 設計模式與管理介面","uri":"/rabbitmq-intro/"},{"categories":["Data Engineering"],"content":"5. Topics 模式 Receiving messages based on a pattern (sample code) Topics\" Topics Topics 與 Routing 模式很像，同樣有一層 Exchange(type=topic)，也透過 routing key 來分流訊息，差別在 topic **的特性能夠模糊綁定非固定的 routing key。 設定模糊 routing key 的 patten 必須是以 .(dot) 分隔的字串，*(star) 只能代替一個單詞、#(bash) 可以代替零個或多個單詞。 我們用上圖的的範例讓你搞懂這到底是啥鬼XD 假設我們要發送「描述動物的訊息」，訊息將使用由三個單詞（包含兩個 .）組成的 routing key 發送，第一個單詞是“速度”，第二個單詞是顏色”，第三個單詞是“物種”：..。 我們將 Exchange 與 Q1 以 “.orange.” 綁定，與 Q2 以 “..rabbit” 和 “lazy.#” 綁定。這可以理解為： Q1 會收到所有關於“橘色動物”的訊息（第二個單詞為 orange） Q2 會收到所有關於“兔子”的訊息，以及所有關於“懶惰動物”的訊息。（第三個單詞為 rabbit，或第一個單詞 lazy） 以下為 Producer 傳入的訊息及結果： “quick.orange.rabbit” 會進入兩個 Queue：Q1 及 Q2 “lazy.orange.elephant” 會進入兩個 Queue：Q1 及 Q2 “quick.orange.fox” 會進入一個 Queue：Q1 “lazy.brown.fox” 會進入一個 Queue：Q2 “lazy.pink.rabbit” 會進入一個 Queue：Q2（僅一次，即使匹配兩個綁定） “quick.brown.fox” 不會進入任何 Queue（與任何綁定都不匹配） 再讓我們看一些特殊的案例： “orange” 不會進入任何 Queue（違反 “.orange.”，前後各缺少一個單詞） “quick.orange.male.rabbit” 不會進入任何 Queue（違反 “..rabbit”，前後多出一個單詞） “lazy.orange.male.rabbit” 會進入一個 Queue：Q2（即使它有四個單詞，也與 “lazy.#” 匹配。 ","date":"2022-02-28","objectID":"/rabbitmq-intro/:3:5","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 設計模式與管理介面","uri":"/rabbitmq-intro/"},{"categories":["Data Engineering"],"content":"下載＆安裝 RabbitMQ 介紹完五種模式，你是不是已經很想動手實作看看？ 接下來就要告訴大家如何自己搭建 RabbitMQ，官方有提供 RabbitMQ Server 在不同作業系統(Linux, MacOS \u0026 Windows)上的安裝指南，不過我還是推薦使用 Docker 建立環境最簡單。 ","date":"2022-02-28","objectID":"/rabbitmq-intro/:4:0","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 設計模式與管理介面","uri":"/rabbitmq-intro/"},{"categories":["Data Engineering"],"content":"Docker 指令 # for RabbitMQ 3.9, the latest series docker run --rm --name rabbitmq -p 5672:5672 -p 15672:15672 -e RABBITMQ_DEFAULT_USER=root -e RABBITMQ_DEFAULT_PASS=1234 rabbitmq:management docker run 執行容器 --rm 當容器終止時會自動刪除 --name rabbitmq 將容器命名為 rabbitmq -p 5672:5672 將本機端的 5672 port 關聯到容器裡的 5672 port（RabbitMQ） -p 15672:15672 將本機端的 15672 port 關聯到容器裡的 15672 port（Web UI） -e RABBITMQ_DEFAULT_USER=root 宣告環境變數，連線到 RabbitMQ 的 username -e RABBITMQ_DEFAULT_PASS=1234 宣告環境變數，連線到 RabbitMQ 的 password rabbitmq:management 指定容器抓 docker hub 上的 rabbitmq official image 預設為最新版本(3.9)，若想要指定版本可以用 rabbitmq:3.8-management ","date":"2022-02-28","objectID":"/rabbitmq-intro/:4:1","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 設計模式與管理介面","uri":"/rabbitmq-intro/"},{"categories":["Data Engineering"],"content":"Docker Compose 指令 # Create and start containerdocker-compose -f docker-compose up# docker-compose.ymlservices: rabbitmq: image: rabbitmq:management container_name: rabbitmq ports: - 5672:5672 - 15672:15672 environment: - RABBITMQ_DEFAULT_USER=root - RABBITMQ_DEFAULT_PASS=1234 docker-compose.yml 檔內的參數定義與 Docker 指令相同 將 RabbitMQ 啟動後，在瀏覽器 http://localhost:15672 進入 RabbitMQ 的網頁版管理介面，如果能成功進入這個畫面，代表服務 RabbitMQ 已經可以使用了。 截圖 ","date":"2022-02-28","objectID":"/rabbitmq-intro/:4:2","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 設計模式與管理介面","uri":"/rabbitmq-intro/"},{"categories":["Data Engineering"],"content":"Web 管理介面 輸入剛剛設定的 RABBITMQ_DEFAULT_USER 和 RABBITMQ_DEFAULT_PASS 登入，就會進入 ","date":"2022-02-28","objectID":"/rabbitmq-intro/:5:0","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 設計模式與管理介面","uri":"/rabbitmq-intro/"},{"categories":["Data Engineering"],"content":"這陣子在開發一個 ML Product，為了要把系統架構解耦，改成異步分散式處理，因而接觸到訊息佇列(Message Queue)，作為兩個子系統（商品資料爬蟲 \u0026 圖片/文字向量轉換）的通信中間層，這篇文章將分享我在架設 RabbitMQ 與使用 Python 實作上的學習。","date":"2022-02-27","objectID":"/message-queue/","tags":["queue","message-queue","system design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue(MQ) 介紹","uri":"/message-queue/"},{"categories":["Data Engineering"],"content":"前言 這陣子在開發一個 ML Product，為了要把系統架構解耦，改成異步分散式處理，因而接觸到訊息佇列(Message Queue)，作為兩個子系統（商品資料爬蟲 \u0026 圖片/文字向量轉換）的通信中間層，這篇文章將分享我在架設 RabbitMQ 與使用 Python 實作上的學習。 ","date":"2022-02-27","objectID":"/message-queue/:1:0","tags":["queue","message-queue","system design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue(MQ) 介紹","uri":"/message-queue/"},{"categories":["Data Engineering"],"content":"什麼是 Message Queue(MQ)？ Message Queue - singleMessage Queue - single \" Message Queue - single Message Queue(MQ)是一種訊息傳遞仲介，架構中擁有三個角色，分別為 Producer、Broker 及 Consumer，提供不同程序(process)或不同系統(system)的非同步(asynchronous)溝通。 什麼是非同步呢？ 一般常見的 HTTP API 就屬於同步式方法，發送方(sender)發出請求(request)等待接收方(receiver)處理完回應(response)，等待過程連結不能斷開去做其他事。 由於先進先出(FIFO)的特性，發送方(producer)只要把訊息/任務往 MQ(broker) 裡面丟，接收方(consumer)就能夠依序從 MQ(broker)中取出訊息/任務，使雙方能夠獨立運作。 ","date":"2022-02-27","objectID":"/message-queue/:2:0","tags":["queue","message-queue","system design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue(MQ) 介紹","uri":"/message-queue/"},{"categories":["Data Engineering"],"content":"使用 Message Queue 有什麼好處？ ","date":"2022-02-27","objectID":"/message-queue/:3:0","tags":["queue","message-queue","system design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue(MQ) 介紹","uri":"/message-queue/"},{"categories":["Data Engineering"],"content":"任務緩衝 短時間內收到大量請求可能會導致系統過載，特別是 CPU / GPU 運算吃重(heavy computing)的情況，這時候 MQ 就發揮了緩衝的功能，Producer 不需等待地發送任務；Consumer 依自己的資源或算力取出適量的任務，處理完再繼續拿。 ","date":"2022-02-27","objectID":"/message-queue/:3:1","tags":["queue","message-queue","system design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue(MQ) 介紹","uri":"/message-queue/"},{"categories":["Data Engineering"],"content":"暫存容錯 若 Consumer 意外關閉，未處理完的訊息/任務還會存在 MQ 內，並不會丟失，只要再把 Consumer 重啟，又可以接續處理。 ","date":"2022-02-27","objectID":"/message-queue/:3:2","tags":["queue","message-queue","system design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue(MQ) 介紹","uri":"/message-queue/"},{"categories":["Data Engineering"],"content":"系統解耦 架構設計上拆分為不同元件(components)獨立開發，Producer、Broker 及 Consumer 不需部署在同一台機主機，不需知道彼此的 IP address，不用使用相同的程式語言。 ","date":"2022-02-27","objectID":"/message-queue/:3:3","tags":["queue","message-queue","system design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue(MQ) 介紹","uri":"/message-queue/"},{"categories":["Data Engineering"],"content":"水平擴展 Message Queue - multiMessage Queue - multi \" Message Queue - multi Producer 可分散在不同來源、裝置收集（e.g. IoT applications）；Consumer 可以按照需求和資源，起在多台機器上，加速訊息/任務的處理。 ","date":"2022-02-27","objectID":"/message-queue/:3:4","tags":["queue","message-queue","system design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue(MQ) 介紹","uri":"/message-queue/"},{"categories":["Data Engineering"],"content":"常見工具 [icon images] Message Queue 常見的開源工具有 RabbitMQ、Redis、Kafka（不同特性可參考這篇：）。 雲端服務則是像是 GCP 的 Cloud Pub/Sub 和 AWS 的 Amazon SQS。 ","date":"2022-02-27","objectID":"/message-queue/:4:0","tags":["queue","message-queue","system design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue(MQ) 介紹","uri":"/message-queue/"},{"categories":["DevOps"],"content":"前言 自從去年初啟動“敏捷”(Scrum)導入，幾乎都在適應(迭代)各種流程、方法和工具，工程實踐方面的單元測試和 CI/CD 推行計畫卻一直往後延。如今，因應團隊一個大型系統要進行前後端分離重構，加上大家對於容器化技術越來越熟悉，同時又有優秀的新夥伴加入，可謂是天時地利人和啊，我們終於要開始在“開發”上實踐敏捷，啟動 CI/CD 導入！ 這此之前我對 CI/CD 的理解幾乎是一片空白，因此想利用這篇文章，記錄過程中的學習心得與知識整理。首先將介紹「什麼是 CI/CD？」、「為什麼要 CI/CD？」、「CI/CD 如何做？」以及「常見的 CI/CD 工具」，您可以透過右側選單快速跳轉至有興趣之章節。內容會比較初淺，請小心服用。 歡迎給予任何反饋和指正～ ","date":"2022-02-13","objectID":"/cicd-intro/:1:0","tags":["CI/CD","DevOps"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-intro/"},{"categories":["DevOps"],"content":"什麼是 CI/CD？ 敏捷式軟體開發生命週期中，從開發、測試到部署是一系列持續迭代的過程，CI/CD 指的是持續整合和持續交付或持續部署的組合實踐。CI/CD通過在應用程式的構建、測試和部署中實施自動化，在開發和運營團隊之間架起了橋梁。 ","date":"2022-02-13","objectID":"/cicd-intro/:2:0","tags":["CI/CD","DevOps"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-intro/"},{"categories":["DevOps"],"content":"CI 持續整合 (Continuous Integration, CI) 每當開發人員 push 程式碼變更到 remote repository 時，觸發自動化 build 和 test 的程序，確保這次的變更是符合規範且通過所有測試案例的，減少有問題的程式碼影響到生產環境的機會。 ","date":"2022-02-13","objectID":"/cicd-intro/:2:1","tags":["CI/CD","DevOps"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-intro/"},{"categories":["DevOps"],"content":"CD 持續交付 / 持續部署 (Continuous Delivery / Continuous Deployment) 完成 Build 和 Test 的下一步就是程式碼部署啦，而 Continuous Delivery 和 Continuous Deployment 的差別就是人為手動部署和自動化部署而已。 ","date":"2022-02-13","objectID":"/cicd-intro/:2:2","tags":["CI/CD","DevOps"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-intro/"},{"categories":["DevOps"],"content":"CI/CD Workflow 從上面這張流程圖的可以看出 CI/CD 主要的工作流：(1)當專案程式碼提交 (commit → push / merge)；(2)進入 CI Pipeline，建立一個測試環境，跑過所有單元測試+整合測試、程式碼規範檢查；(3)進入 CD Pipeline，完成程式碼部署。 ","date":"2022-02-13","objectID":"/cicd-intro/:2:3","tags":["CI/CD","DevOps"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-intro/"},{"categories":["DevOps"],"content":"為什麼要 CI/CD？ ","date":"2022-02-13","objectID":"/cicd-intro/:3:0","tags":["CI/CD","DevOps"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-intro/"},{"categories":["DevOps"],"content":"CI/CD = 自動化測試 + 自動部署？ 看完前面的介紹，可能會認為 CI/CD 只是寫腳本跑自動化測試 + 自動部署，然而 “Continuous” 的意義是“頻繁地”釋出新版本，降低過大變動帶來的問題與衝突，從 3 個月發佈 1 次，到 1 天發佈 3 次，達到敏捷精神中小步快跑、快速迭代的狀態。 ","date":"2022-02-13","objectID":"/cicd-intro/:3:1","tags":["CI/CD","DevOps"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-intro/"},{"categories":["DevOps"],"content":"CD/CD 的好處 CI/CD 可以為團隊帶來以下好處，同時也是我們所追求的目標： 避免版本衝突 降低人為操作失誤 減少人工時間花費 及早發現(bug)及早修正(fix) 專注開發提高生產力 加速產品迭代 (001_cicd-intro/Untitled%202.png “Happiness for Developer”) 延伸思考： ＊題外話，這些目標其實都不太具體，還需要進一步透過量化指標來評估 CI/CD 成效，有興趣的朋友可參考這篇 衡量和監控 CI/CD 性能。 ","date":"2022-02-13","objectID":"/cicd-intro/:3:2","tags":["CI/CD","DevOps"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-intro/"},{"categories":["DevOps"],"content":"CI/CD 如何做？ 為了達到快速又頻繁的新版本發佈，必須要有嚴謹和穩健的流程，從前面的 CI/CD Workflow 可見步驟相當繁瑣且有相依性，因此需要透過工具和指令，有效地自動化幫我們執行這些程序。 ","date":"2022-02-13","objectID":"/cicd-intro/:4:0","tags":["CI/CD","DevOps"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-intro/"},{"categories":["DevOps"],"content":"先備知識與技能 做 CI/CD 之前，建議團隊要有一定的成熟度，才能快速將現有的程序轉換為自動化的方式運行，以下是我認為必須先具備的知識和技能，導入 CI/CD 時較能快速上手： Shell Script(Command)：與作業系統 Kernel 互動的語言(指令)是一切的基礎 SSH 連線：創建公鑰和私鑰，以特定使用者連線至遠端 Server 進行操作 Git 版本控制、任何一種 Git workflow：用來管理分支、切換版本、合併流程 容器化技術：用來隔離環境，快速搭建和部署（e.g. docker, docker-compose) 程式碼規範檢查：檢查你的程式碼，是否符合團隊規範的程式碼風格 單元測試、整合測試、自動化測試：檢查你的程式碼，能否在目標環境正常運作 ","date":"2022-02-13","objectID":"/cicd-intro/:4:1","tags":["CI/CD","DevOps"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-intro/"},{"categories":["DevOps"],"content":"流程與準備 上述的知識與技能你都已經掌握了之後，開始盤點 CI/CD 各個步驟會用到的指令，接著確認這些指令的順序（哪些具有相依性？哪些可以平行化？） GitLab CI/CD Pipeline(source: https://docs.gitlab.com/ee/ci/pipelines/ “GitLab CI/CD Pipeline(source: aaa\u003ca href=\"https://docs.gitlab.com/ee/ci/pipelines/\" target=\"_blank\" rel=\"noopener noreffer\"\u003ehttps://docs.gitlab.com/ee/ci/pipelines/\u003c/a\u003e)\u0026quot;) \" aaa 這邊建議先將工作流程的 DAG (Directed Acyclic Graph，有向無環圖)畫出來，然後手動執行一遍所有流程（這時有就能感受到人工做這些事其實相當繁瑣及耗時），下一步就是將相同的程序透過工具自動化執行啦！ ","date":"2022-02-13","objectID":"/cicd-intro/:4:2","tags":["CI/CD","DevOps"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-intro/"},{"categories":["DevOps"],"content":"CI/CD 工具 常見的 CI/CD 工具有 Jenkins、GitLab、Circle CI、Travis CI、Drone 等，另外，各大雲端平台(AWS, GCP, Azure)也有推出 CI/CD 解決方案，更好地整合了自家的雲端服務。 **Continuous delivery tool landscape (**source: **Continuous delivery tool landscape (**source: http://www.jamesbowman.me/post/continuous-delivery-tool-landscape/) 一般我們會希望這些工具通常具備以下功能： 最基本的建立、編輯腳本 相容各 Git 程式碼託管平台 視覺化呈現工作流(Workflow)、狀態(Status)和進度(Progress) 管理不同使用者權限(Maintainer, Developer, Reviewer, etc.) 可將任務分散給多個 Runner / Worker 執行 設定成功 / 失敗發送信件通知 支持第三方工具整合 … 我目前團隊用的程式碼託管平台是 GitLab，評估過後發現 GitLab 的 CI/CD 解決方案很棒，因此選用為我們的工具，並開始逐步導入。（下一篇文章將會介紹使用方式） ","date":"2022-02-13","objectID":"/cicd-intro/:4:3","tags":["CI/CD","DevOps"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-intro/"},{"categories":["DevOps"],"content":"總結 好的 CI/CD 可以幫助團隊減少人為失誤，提高生產力，加速產品迭代；壞的 CI/CD 可能會導致流程更加混亂，增加人力除錯成本，造成品質低落。 所以你應該依團隊目前的成熟度，逐步將 CI/CD 各個環節添加進去，不需要一次就全部導入，例如：單元測試尚未落實的團隊，進入 CI 階段前可以先透過 Code Review 檢查；自動部署尚未穩定的團隊，CD 階段可以只做到自動交付，保留最後一步由人工進行部署。 最後，期望團隊今年可以在各大專案中導入，也期許自己保有持續輸出(Continuous Output)、持續分享(Continuous Sharing)的精神XD ","date":"2022-02-13","objectID":"/cicd-intro/:5:0","tags":["CI/CD","DevOps"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-intro/"},{"categories":["DevOps"],"content":"參考 https://docs.gitlab.com/ee/ci/ https://www.redhat.com/zh/topics/devops/what-is-ci-cd https://bear-1111.medium.com/什麼是-ci-cd-72bd5ae571f1 https://blog.kennycoder.io/2020/04/07/CI-CD-持續性整合-部署-因為懶，所以更要CI-CD！概念講解！/ ","date":"2022-02-13","objectID":"/cicd-intro/:6:0","tags":["CI/CD","DevOps"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-intro/"},{"categories":null,"content":"關於我 我是 Enzo，熱衷分享的學習愛好者，目前在一間電商平台擔任 Data Engineer (80%)，身兼 Scrum Master (20%)，陪伴團隊快步迭代。曾經在接案公司擔任軟體工程師和專案經理，經歷各種隕石需求和合約戰爭荼毒，遇見敏捷後，深深受其價值觀所吸引，致力成為身心合一的敏捷實踐家！ ","date":"2021-10-26","objectID":"/about/:0:1","tags":null,"title":"關於本站","uri":"/about/"},{"categories":null,"content":"架站動機 架設這個部落格的目的是想記錄自己在工作上或日常中的成長歷程，因為我認為學習必須經過自己的整理和輸出，梳理自己對於知識概念的，形成自己的觀點。過去我雖然有在社群媒體發文，但其觸及率極低且無法被搜尋引擎找到，因此，想要建立這個專屬的空間，集中並擴大影響力。 ","date":"2021-10-26","objectID":"/about/:0:2","tags":null,"title":"關於本站","uri":"/about/"},{"categories":null,"content":"寫文方向 這個部落格的文章主題會以「 資料工程 Data Engineering 」、「 敏捷 Agile/Scrum 」、「 職涯探索 Career」為主，內容類型可能為學習筆記、實作教學、經驗分享、個人觀點等。 ","date":"2021-10-26","objectID":"/about/:0:3","tags":null,"title":"關於本站","uri":"/about/"},{"categories":null,"content":"行動期許 期許自己能夠堅持寫文，幫助自己也能幫助到別人，也歡迎你與我連結、互相交流。 ","date":"2021-10-26","objectID":"/about/:0:4","tags":null,"title":"關於本站","uri":"/about/"},{"categories":null,"content":"聯繫我 Facebook：https://www.facebook.com/enzoapu Linkedin：https://www.linkedin.com/in/enzochang E-mail：enzoapu@gmail.com PyData Taipei 2020https://pydata.org/taipei2020/program/talk-14/ \" PyData Taipei 2020 ","date":"2021-10-26","objectID":"/about/:0:5","tags":null,"title":"關於本站","uri":"/about/"}]