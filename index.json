[{"categories":["Data Engineering"],"content":"上一篇介紹完 RabbitMQ 的架構和設計模式，接下來就要告訴大家如何自己搭建 RabbitMQ Server，不用幾行程式碼就可以在本機或是虛擬主機把服務架起來，還提供了一個 Web 管理介面方便你瀏覽和操作。","date":"2022-03-15","objectID":"/rabbitmq-management-interface/","tags":["rabbitmq","web-user-interface","docker","installation"],"title":"[DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面","uri":"/rabbitmq-management-interface/"},{"categories":["Data Engineering"],"content":"前言 上一篇介紹完 RabbitMQ 的架構和設計模式，接下來就要告訴大家如何自己搭建 RabbitMQ Server，不用幾行程式碼就可以在你本機或是虛擬主機把服務架起來，還提供了一個 Web 管理介面方便你瀏覽和操作。 [ 系列文章目錄 ] [DATA] 訊息佇列 01 - Message Queue 介紹與實際應用 [DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式 [DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面（本篇） [DATA] 訊息佇列 04 - RabbitMQ x Python 程式實作範例（待完成） ","date":"2022-03-15","objectID":"/rabbitmq-management-interface/:1:0","tags":["rabbitmq","web-user-interface","docker","installation"],"title":"[DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面","uri":"/rabbitmq-management-interface/"},{"categories":["Data Engineering"],"content":"RabbitMQ 環境架設 RabbitMQ 官方有提供 RabbitMQ Server 在不同作業系統(Linux, MacOS \u0026 Windows)上的安裝指南，不過我還是推薦使用 Docker / Docker Compose 建立環境最為簡單、快速。 ","date":"2022-03-15","objectID":"/rabbitmq-management-interface/:2:0","tags":["rabbitmq","web-user-interface","docker","installation"],"title":"[DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面","uri":"/rabbitmq-management-interface/"},{"categories":["Data Engineering"],"content":"使用 Docker 指令 # create and start container docker run --rm --name rabbitmq -p 5672:5672 -p 15672:15672 \\ -e RABBITMQ_DEFAULT_USER=root -e RABBITMQ_DEFAULT_PASS=1234 rabbitmq:management 指令 \u0026 參數 定義說明 docker run 執行容器 --rm 當容器終止時會自動刪除 --name rabbitmq 將容器命名為 rabbitmq -p 5672:5672 將本機端的 5672 port 關聯到容器的 5672 port（RabbitMQ） -p 15672:15672 將本機端的 15672 port 關聯到容器的 15672 port（Web UI） -e RABBITMQ_DEFAULT_USER=root 宣告環境變數，連線到 RabbitMQ 的 username -e RABBITMQ_DEFAULT_PASS=1234 宣告環境變數，連線到 RabbitMQ 的 password rabbitmq:management 指定容器抓 Docker Hub 上的 RabbitMQ Official Omage docker image version 預設為最新版本(3.9)，若想要指定版本可以替換標籤(tag)，例：rabbitmq:3.8-management 為 3.8 版 ","date":"2022-03-15","objectID":"/rabbitmq-management-interface/:2:1","tags":["rabbitmq","web-user-interface","docker","installation"],"title":"[DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面","uri":"/rabbitmq-management-interface/"},{"categories":["Data Engineering"],"content":"使用 Docker Compose 指令 # create and start container docker-compose -f docker-compose.yml up docker-compose.yml 的參數定義與 Docker 指令完全一致。 # docker-compose.ymlservices:rabbitmq:image:rabbitmq:managementcontainer_name:rabbitmqports:- 5672:5672- 15672:15672environment:- RABBITMQ_DEFAULT_USER=root- RABBITMQ_DEFAULT_PASS=1234 ","date":"2022-03-15","objectID":"/rabbitmq-management-interface/:2:2","tags":["rabbitmq","web-user-interface","docker","installation"],"title":"[DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面","uri":"/rabbitmq-management-interface/"},{"categories":["Data Engineering"],"content":"進入 RabbitMQ 將 RabbitMQ 啟動後，在瀏覽器 http://localhost:15672 進入 RabbitMQ 網頁管理介面，如果能成功進入「登入頁面」，代表 RabbitMQ 已經成功在本機(localhost)架設起來了！ RabbitMQ Web UI - LoginRabbitMQ Web UI - Login \" RabbitMQ Web UI - Login 公開存取 如果你是架設在伺服器或虛擬主機上，只要開啟防火牆 TCP 15672 port，其他人就可以透過 Public IP 進入你的 RabbitMQ 網頁管理介面 http://\u003cyour_puclic_ip_address\u003e:15672 ","date":"2022-03-15","objectID":"/rabbitmq-management-interface/:2:3","tags":["rabbitmq","web-user-interface","docker","installation"],"title":"[DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面","uri":"/rabbitmq-management-interface/"},{"categories":["Data Engineering"],"content":"RabbitMQ 網頁管理介面 rabbitmq:management 這個 Docker Image 有包含 Web 版管理介面，供開發/維運人員透過查看 Queues 的狀態，並可以直接在上面操作，推送(publish)訊息和取出(get)訊息。以下將分別介紹 RabbitMQ 網頁管理介面的主要頁籤功能： ","date":"2022-03-15","objectID":"/rabbitmq-management-interface/:3:0","tags":["rabbitmq","web-user-interface","docker","installation"],"title":"[DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面","uri":"/rabbitmq-management-interface/"},{"categories":["Data Engineering"],"content":"Overview 輸入剛剛設定的 RABBITMQ_DEFAULT_USER 和 RABBITMQ_DEFAULT_PASS 登入後，就會進入「總覽頁面」，顯示 RabbitMQ Server 上的重要資訊和指標。 RabbitMQ Web UI - OverviewRabbitMQ Web UI - Overview \" RabbitMQ Web UI - Overview ","date":"2022-03-15","objectID":"/rabbitmq-management-interface/:3:1","tags":["rabbitmq","web-user-interface","docker","installation"],"title":"[DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面","uri":"/rabbitmq-management-interface/"},{"categories":["Data Engineering"],"content":"Connections 顯示目前 RabbitMQ Server 上所有 Clients 的連線狀態與網路資訊。 RabbitMQ Web UI - ConnectionsRabbitMQ Web UI - Connections \" RabbitMQ Web UI - Connections ","date":"2022-03-15","objectID":"/rabbitmq-management-interface/:3:2","tags":["rabbitmq","web-user-interface","docker","installation"],"title":"[DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面","uri":"/rabbitmq-management-interface/"},{"categories":["Data Engineering"],"content":"Channels 顯示目前 RabbitMQ Server 上所有 Channels 的訊息吞吐量。 RabbitMQ Web UI - ChannelsRabbitMQ Web UI - Channels \" RabbitMQ Web UI - Channels ","date":"2022-03-15","objectID":"/rabbitmq-management-interface/:3:3","tags":["rabbitmq","web-user-interface","docker","installation"],"title":"[DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面","uri":"/rabbitmq-management-interface/"},{"categories":["Data Engineering"],"content":"Exchanges 查看並管理 Exchanges，預設已經建立了幾種不同 Type 的 Exchanges，可以直接使用或是自行手動新增。 RabbitMQ Web UI - ExchangesRabbitMQ Web UI - Exchanges \" RabbitMQ Web UI - Exchanges ","date":"2022-03-15","objectID":"/rabbitmq-management-interface/:3:4","tags":["rabbitmq","web-user-interface","docker","installation"],"title":"[DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面","uri":"/rabbitmq-management-interface/"},{"categories":["Data Engineering"],"content":"Queues 查看並管理每一條 Queue 的訊息(messages)狀態與吞吐量。 RabbitMQ Web UI - LoginRabbitMQ Web UI - Login \" RabbitMQ Web UI - Login 新增 Queue 輸入自訂 \u0008Queue name（唯一值），並設定必要及可選的參數。 RabbitMQ Web UI - LoginRabbitMQ Web UI - Login \" RabbitMQ Web UI - Login Durablity Durable 在 RabbitMQ 關閉/重啟後訊息還會留存；Transient 在 RabbitMQ 關閉/重啟後就不存在了。 Auto delete 若選 Yes，Queue 會在所有 Consumer 都中斷連接時自行刪除。 Aruguments Message TTL：Queue 裡的訊息在多少時間（毫秒）內若沒有被取用就會被丟棄 Auto expire：Queue 在多少時間（毫秒）內若都沒有被使用就會自動刪除 Single active connsumer：這條 Queue 是否只能有一個存活的 Consumer Max length：Queue 最多保存的訊息量，若超過會從頭端（FIFO）丟棄訊息 Max length bytes：Queue 最多保存的訊息長度，若超過會從頭端（FIFO）丟棄訊息 訊息長度限制 若 Max length 為 1000，單一訊息 12 bytes，代表 Queue 最多能保存 1000 則訊息； 若 Max length bytes 為 10000，單一訊息 12 bytes，代表最多只能存 10000/12=833 則訊息 Queue 的訊息可能會因為過期（MMessage TTL）或超過限制（Max length）被丟棄，透過以下兩個 Arguments 設定這些訊息要被重新推送至哪裡。 Dead letteer exchange：被丟棄的訊息要被推送進入的 Exchange Dead letteer routing key：\u0008Dead letteer exchange 要綁定(binding) Queue 的 Routing key 管理 Queue 點選上面建立的 test-ueue 進入 Queue 內容頁面，在這裡可以： 查看 Messages 的詳細資訊和速率指標 設定 Queue 要綁定(binding)的 Exchange 和 Routing key 查看連接的 Consumer(s) 推送訊息、取出一至多則訊息 刪除(delete)整條 Queue 清空(purge)整條 Queue 裡的訊息 透過程式碼管理 Queue 雖然在網頁介面上都完成上述操作，但其實對於開發者來說，只要寫程式也能夠簡單地做到，下一篇文章會介紹 RabbitMQ x Python 的實作範例。 Publish / Get message 你可以在介面上試著推送(Publish)訊息，再取出(Get)訊息，你將依序地得到這些訊息。 RabbitMQ Web UI - LoginRabbitMQ Web UI - Login \" RabbitMQ Web UI - Login 測試的同時你可觀察訊息圖表的即時變化。（網頁預設 Refresh every 5 seconds） RabbitMQ Web UI - LoginRabbitMQ Web UI - Login \" RabbitMQ Web UI - Login ","date":"2022-03-15","objectID":"/rabbitmq-management-interface/:3:5","tags":["rabbitmq","web-user-interface","docker","installation"],"title":"[DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面","uri":"/rabbitmq-management-interface/"},{"categories":["Data Engineering"],"content":"Admin 最初使用的 DEFAULT 帳密是最高權限使用者，若想把帳號分給其他人，可在這個頁面管理 Users 或新增 User。 RabbitMQ Web UI - LoginRabbitMQ Web UI - Login \" RabbitMQ Web UI - Login ","date":"2022-03-15","objectID":"/rabbitmq-management-interface/:3:6","tags":["rabbitmq","web-user-interface","docker","installation"],"title":"[DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面","uri":"/rabbitmq-management-interface/"},{"categories":["Data Engineering"],"content":"參考 https://www.rabbitmq.com/queues.html https://kucw.github.io/blog/2020/11/rabbitmq/ https://godleon.github.io/blog/ChatOps/message-queue-concepts/ ","date":"2022-03-15","objectID":"/rabbitmq-management-interface/:4:0","tags":["rabbitmq","web-user-interface","docker","installation"],"title":"[DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面","uri":"/rabbitmq-management-interface/"},{"categories":["Data Engineering"],"content":"上一篇文章介紹完 Message Queue 是什麼後，這次要介紹的是知名且易用的實作工具 RabbitMQ，本篇文章將帶大家認識 RabbitMQ 的架構以及 5 種設計模式。","date":"2022-03-06","objectID":"/rabbitmq-intro/","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式","uri":"/rabbitmq-intro/"},{"categories":["Data Engineering"],"content":"前言 上一篇文章介紹完 Message Queue 是什麼後，這次要介紹的是知名且易用的實作工具 RabbitMQ，本篇文章將帶大家認識 RabbitMQ 的架構以及 5 種設計模式。 [ 系列文章目錄 ] [DATA] 訊息佇列 01 - Message Queue 介紹與實際應用 [DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式（本篇） [DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面 [DATA] 訊息佇列 04 - RabbitMQ x Python 程式實作範例（待完成） ","date":"2022-03-06","objectID":"/rabbitmq-intro/:1:0","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式","uri":"/rabbitmq-intro/"},{"categories":["Data Engineering"],"content":"RabbitMQ 簡介 RabbitMQ 是使用廣泛的輕量級開源工具，支持 AMQP 0-9-1 等多種訊息傳遞協定。 RabbitMQ 容易在本地端和雲端部署，滿足大規模(分散式)、高可用性的需求。 RabbitMQ 為大多數流行的程式語言提供了多樣的開發套件包。(Python, Java, Ruby, PHP, C#, JS, Go, etc.) RabbitMQ 提供了一個 Web 使用者介面來管理權限並監控各種狀態、指標。 ","date":"2022-03-06","objectID":"/rabbitmq-intro/:2:0","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式","uri":"/rabbitmq-intro/"},{"categories":["Data Engineering"],"content":"RabbitMQ 架構 RabbitMQ ArchitectureRabbitMQ Architecture \" RabbitMQ Architecture 看完上一篇我們已經知道 Message Queue 架構中的三個角色，在 RabbitMQ 中也延用相同概念： Producer 是發送訊息的應用程式 Queue 是儲存訊息的緩衝區 Consumer 是接收訊息的應用程式 不過在 RabbitMQ 中，根據不同設計模式會在 Producer 與 Queue 之間加上一層 Exchange： Exchange 的工作很簡單，透過綁定(binding)與 Queue 連結，負責接收來自 Producer 的訊息，然後將訊息推送給 Queue。 透過定義 Exchange 的類型(type)來判斷要如何處理收到的訊息，是要推送給哪個特定 Queue？還是要推送給多個 Queue？或是應該被丟棄？ Exchange 的類型(type)有分為 direct, topic \u0026 fanout，文章下個段落介紹不同模式時會探討差別。 RabbitMQ Exchange TypesRabbitMQ Exchange Types \" RabbitMQ Exchange Types -- ","date":"2022-03-06","objectID":"/rabbitmq-intro/:3:0","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式","uri":"/rabbitmq-intro/"},{"categories":["Data Engineering"],"content":"RabbitMQ 設計模式 根據 RabbitMQ Tutorials 官方的範例，展示了五種常見的模式（Python 範例程式碼附在標題後方連結）： ","date":"2022-03-06","objectID":"/rabbitmq-intro/:4:0","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式","uri":"/rabbitmq-intro/"},{"categories":["Data Engineering"],"content":"1. Simple 模式 The simplest thing that does something (sample code) RabbitMQ - Simple\" RabbitMQ - Simple 最基本的一種模式，只有一個 Queue(定義 Queue 的名稱)，Producer 直接將訊息傳進這個 Queue(hello)，也只有一個 Consumer 從這個 Queue(hello) 取出訊息。 ","date":"2022-03-06","objectID":"/rabbitmq-intro/:4:1","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式","uri":"/rabbitmq-intro/"},{"categories":["Data Engineering"],"content":"2. Worker 模式 Distributing tasks among workers (sample code) RabbitMQ - Worker\" RabbitMQ - Worker 相比 Simple，Worker 模式會有兩個以上的 Consumer(Worker)，從同一個 Queue 取出訊息，且 Consumer 彼此間不會取得相同的訊息，加速訊息處理(消化)速度。因此只要連接同一個 Queue，就可以在多台機器上 Consumer 平行處理。 。 預取數量(prefetch count) 可透過 prefetch_count 參數，控制每個 Consumer(Worker) 每一次取出的訊息數量，假設 Producer 將 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 依序傳進 Queue： 在 prefetch_count = 1 的情況 C1 依序取出 1、3、5、7、9 (共五次) C2 依序取出 2、4、6、8、10 (共五次) 在 prefetch_count = 2 的情況 C1 依序取出 1,2、5,6、9,10 (共三次) C2 依序取出 3,4、7,8(共兩次) ","date":"2022-03-06","objectID":"/rabbitmq-intro/:4:2","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式","uri":"/rabbitmq-intro/"},{"categories":["Data Engineering"],"content":"3. Publish/Subscribe 模式 Sending messages to many consumers at once (sample code) RabbitMQ - Publish/Subscribe\" RabbitMQ - Publish/Subscribe Publish/Subscribe 模式顧名思義，就像你訂閱某個 YT 頻道，當頻道創作者發佈了新影片，連同你的所有訂閱者都會收到通知。 Producer 不會將訊息直接傳進 Queue，而是交給 Exchange (type=fanout)，由於 fanout 的特性，Exchange 會把訊息廣播給所有綁定的 Queue，每個 Consumer 就會接收到相同的訊息。因此當有另外的系統需要同步接收訊息，只需增加一組 Queue + Producer，綁定這個 Exchange 即可。 ","date":"2022-03-06","objectID":"/rabbitmq-intro/:4:3","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式","uri":"/rabbitmq-intro/"},{"categories":["Data Engineering"],"content":"4. Routing 模式 Receiving messages selectively (sample code) RabbitMQ - Routing\" RabbitMQ - Routing Routing 模式同樣有一層 Exchange (type=direct)，但不同的是 direct 的特性，Exchange 與 Queue 的綁定(binding)還會帶上 routing key，Producer 傳送訊息到 Exchange 時也會帶上 routing key 這個參數。因此可以達到選擇性訊息分流，不同 Consumer 只需要接受到特定 routing 的訊息。 日誌系統(logging system) RabbitMQ - Logging system\" RabbitMQ - Logging system 上圖為此 日誌系統(logging system) 的範例，使用兩組 Queue： Q1 只有綁定一個 routing key(error)，因此負責寫檔(log file)的 C1 只會接收 error log messages，可節省硬碟(disk)空間。 Q2 則是綁定多個 routing key(info, warning \u0026 error)，負責打印到控制台(console)的 C2 仍然可輸出所有層級(level)的 log messages。 ","date":"2022-03-06","objectID":"/rabbitmq-intro/:4:4","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式","uri":"/rabbitmq-intro/"},{"categories":["Data Engineering"],"content":"5. Topics 模式 Receiving messages based on a pattern (sample code) RabbitMQ - Topics\" RabbitMQ - Topics Topics 與 Routing 模式很像，同樣有一層 Exchange (type=topic)，也透過 routing key 來分流訊息，差別在 topic 的特性能夠模糊綁定非固定的 routing key。 設定模糊 routing key 的 patten 必須是以 .(dot) 分隔的字串，*(star) 只能代替一個單詞、#(bash) 可以代替零個或多個單詞。 很難理解對吧XD 我們用上圖作為範例來解釋就會懂了！ 假設我們要發送的是「 描述動物的訊息 」，訊息將使用由三個單詞（包含兩個 .）組成的 routing key 發送，第一個單詞是 “速度”，第二個單詞是 “顏色”，第三個單詞是 “物種”：\u003c速度\u003e.\u003c顏色\u003e.\u003c物種\u003e。 我們將 Exchange 與 Q1 以 .orange. 綁定，與 Q2 以 *.*.rabbit 和 lazy.# 綁定，也就是： Q1 會收到所有關於 “橘色動物” 的訊息 Q2 會收到所有關於 “兔子” 的訊息，以及所有關於 “懶惰動物” 的訊息 以下為 P 傳入的訊息及結果： quick.orange.rabbit 會進入兩個 Queue：Q1 及 Q2 lazy.orange.elephant 會進入兩個 Queue：Q1 及 Q2 quick.orange.fox 會進入一個 Queue：Q1 lazy.brown.fox 會進入一個 Queue：Q2 lazy.pink.rabbit 會進入一個 Queue：Q2（僅一次，即使匹配兩個綁定） quick.brown.fox 不會進入任何 Queue（與任何綁定都不匹配） 再讓我們看一些訊息長度特殊的案例： orange 不會進入任何 Queue（違反 “.orange.”，前後各缺少一個單詞） quick.orange.male.rabbit 不會進入任何 Queue（違反 *.*.rabbit，前後多出一個單詞） lazy.orange.male.rabbit 會進入一個 Queue：Q2（即使它有四個單詞，還是與 lazy.# 匹配） ","date":"2022-03-06","objectID":"/rabbitmq-intro/:4:5","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式","uri":"/rabbitmq-intro/"},{"categories":["Data Engineering"],"content":"參考 https://godleon.github.io/blog/ChatOps/message-queue-concepts/ https://kucw.github.io/blog/2020/11/rabbitmq/ https://homuchen.com/posts/message-queue-advantages-use-cases/ https://www.cloudamqp.com/blog/part1-rabbitmq-for-beginners-what-is-rabbitmq.html https://www.cloudamqp.com/docs/amqp.html ","date":"2022-03-06","objectID":"/rabbitmq-intro/:5:0","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式","uri":"/rabbitmq-intro/"},{"categories":["Data Engineering"],"content":"這陣子團隊在開發相似商品搜尋的 ML Product，為了要把系統架構解耦，改為異步分散式處理，因而接觸到訊息佇列(Message Queue)，作為兩個子系統（商品資料爬蟲 \u0026 圖片/文字向量轉換）的通信中間層。我將透過四篇文章分享我在使用 RabbitMQ 與 Python 實作的學習。","date":"2022-03-03","objectID":"/message-queue/","tags":["message-queue","system-design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue 介紹與實際應用","uri":"/message-queue/"},{"categories":["Data Engineering"],"content":"前言 這陣子團隊在開發相似商品搜尋的 ML Product，為了要把系統架構解耦，改為異步分散式處理，因而接觸到訊息佇列(Message Queue)，作為兩個子系統（商品資料處理 \u0026 特徵向量轉換）的通信中間層。我將透過四篇文章分享我在使用 RabbitMQ 與 Python 實作的學習。 [ 系列文章目錄 ] [DATA] 訊息佇列 01 - Message Queue 介紹與實際應用（本篇） [DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式 [DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面 [DATA] 訊息佇列 04 - RabbitMQ x Python 程式實作範例（待完成） ","date":"2022-03-03","objectID":"/message-queue/:1:0","tags":["message-queue","system-design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue 介紹與實際應用","uri":"/message-queue/"},{"categories":["Data Engineering"],"content":"什麼是 Message Queue(MQ)？ Message Queue\" Message Queue Message Queue(MQ)是一種訊息傳遞仲介，架構中擁有三個角色，分別為 Producer、Broker 及 Consumer，提供不同程序(process)或不同系統(system)的非同步(asynchronous)溝通。 什麼是非同步呢？ 一般常見的 HTTP API 就屬於同步式方法，發送方(sender) 發出請求(request)，等待接收方(receiver) 處理完回應(response)，等待過程不能斷開連線去做其他事。 Producer：產生 Message 的角色，可能是程式、感測器(sensor)等，負責將訊息傳送給指定的 Broker Broker：就是 Queue 本身（以不同名稱區分)，負責暫存訊息，再依序（先進先出）傳送給 Consumer Consumer：消化 Message 的角色（或稱為 Worker)，負責主動拿取或被動接收 Broker 的訊息 Message：泛指在 Queue 之間流通的訊息（或稱為任務)，包含 routing info（標籤）\u0026 body（內容） 由於先進先出(FIFO)的特性，發送方(producer) 只要把訊息往 MQ(broker) 裡面丟，接收方(consumer) 就能夠依序從 MQ(broker) 中取出訊息，使雙方能夠獨立運作，不需要放在同一套系統內。 ","date":"2022-03-03","objectID":"/message-queue/:2:0","tags":["message-queue","system-design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue 介紹與實際應用","uri":"/message-queue/"},{"categories":["Data Engineering"],"content":"使用 Message Queue 有什麼好處？ ","date":"2022-03-03","objectID":"/message-queue/:3:0","tags":["message-queue","system-design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue 介紹與實際應用","uri":"/message-queue/"},{"categories":["Data Engineering"],"content":"任務緩衝 短時間內收到大量請求可能會導致系統過載，特別是 CPU / GPU 運算吃重(heavy computing)的情況，這時候 MQ 就發揮了緩衝的功能，Producer 不需等待地向 Broker 發送訊息(任務)；Consumer 依自己的資源和算力從 Broker 取出適量的訊息(任務)，處理完再繼續拿。 ","date":"2022-03-03","objectID":"/message-queue/:3:1","tags":["message-queue","system-design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue 介紹與實際應用","uri":"/message-queue/"},{"categories":["Data Engineering"],"content":"暫存容錯 若 Consumer 意外關閉，未處理完的訊息還會存在 MQ 內，並不會丟失，只要再把 Consumer 重啟，又可以接續處理。（通常可設定要暫存或是丟棄） ","date":"2022-03-03","objectID":"/message-queue/:3:2","tags":["message-queue","system-design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue 介紹與實際應用","uri":"/message-queue/"},{"categories":["Data Engineering"],"content":"系統解耦 架構設計上拆分為不同元件(components)獨立開發，Producer、Broker 及 Consumer 不需部署在同一台機主機，不需知道彼此的 IP address，也不需使用相同的程式語言。 ","date":"2022-03-03","objectID":"/message-queue/:3:3","tags":["message-queue","system-design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue 介紹與實際應用","uri":"/message-queue/"},{"categories":["Data Engineering"],"content":"水平擴展 Message Queue - multi\" Message Queue - multi Producer 可分散在不同來源、裝置收集（e.g. IoT applications）；Consumer 可以按照需求和資源，運行在多台機器上，加速訊息(任務)的消化和處理。 ","date":"2022-03-03","objectID":"/message-queue/:3:4","tags":["message-queue","system-design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue 介紹與實際應用","uri":"/message-queue/"},{"categories":["Data Engineering"],"content":"常見工具 Message Queue - Products\" Message Queue - Products Message Queue 常見的開源工具有 RabbitMQ、Redis、Kafka（不同特性可參考 這篇）。 雲端服務則是像是 GCP 的 Cloud Pub/Sub 和 AWS 的 Amazon SQS。 RabbitMQ 下一篇文章，我將介紹目前團隊所使用的 RabbitMQ 有哪些優勢、設計模式、架設方法等等。 ","date":"2022-03-03","objectID":"/message-queue/:4:0","tags":["message-queue","system-design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue 介紹與實際應用","uri":"/message-queue/"},{"categories":["Data Engineering"],"content":"實際應用 這是某相似商品比對產品的 ETL 架構圖（擷取簡化部分），任務是每天將商品資訊（圖片 \u0026 文字）進行向量轉換，\u0008分為會使用到 CV 模型和 NLP 模型，由於 GPU 運算負擔比較重（機器資源、計算時間等），因此將系統拆分為下圖左邊紅底的 Producer 和右邊藍底的 Consumer。 案例架構圖\" 案例架構圖 Producer 負責資料過濾(data filtering)特徵提取(feature extraction)；Consumer 負責任務收集(task collecting)和向量轉換(vectorization)。兩個系統彼此不會直接溝通，而是將 Message 透過 Broker 暫存與傳遞，分為 Image Queue 和 Text Queue，\u0008\u0008並可以根據目標完成時間來調整 Producer 和 Consumer 的數量，加速任務的消化。 這樣的設計相對過去採用 HTTP 連線效率提高（不需互相等待）；部署在不同規格的機器(VM)，Producer 選用低規格的機器，Consumer 選用搭載 GPU 的機器，也可以大大地降低成本。 ","date":"2022-03-03","objectID":"/message-queue/:5:0","tags":["message-queue","system-design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue 介紹與實際應用","uri":"/message-queue/"},{"categories":["Data Engineering"],"content":"參考 https://homuchen.com/posts/message-queue-advantages-use-cases/ https://godleon.github.io/blog/ChatOps/message-queue-concepts/ ","date":"2022-03-03","objectID":"/message-queue/:6:0","tags":["message-queue","system-design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue 介紹與實際應用","uri":"/message-queue/"},{"categories":["DevOps"],"content":"自從去年初啟動“敏捷”(Scrum)導入，幾乎都在適應(迭代)各種流程、方法和工具，工程實踐方面的單元測試和 CI/CD 推行計畫卻一直往後延。如今，因應團隊一個大型系統要進行前後端分離重構，加上大家對於容器化技術越來越熟悉，同時又有優秀的新夥伴加入，可謂是天時地利人和啊，我們終於要啟動 CI/CD 導入！","date":"2022-02-13","objectID":"/cicd-intro/","tags":["cicd","devops"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-intro/"},{"categories":["DevOps"],"content":"前言 自從去年初啟動“敏捷”(Scrum)導入，幾乎都在適應(迭代)各種流程、方法和工具，工程實踐方面的單元測試和 CI/CD 推行計畫卻一直往後延。如今，因應團隊一個大型系統要進行前後端分離重構，加上大家對於容器化技術越來越熟悉，同時又有優秀的新夥伴加入，可謂是天時地利人和啊，我們終於要開始在“開發”上實踐敏捷，啟動 CI/CD 導入！ 這此之前我對 CI/CD 的理解幾乎是一片空白，因此想利用這篇文章，記錄過程中的學習心得與知識整理。首先將介紹「什麼是 CI/CD？」、「為什麼要 CI/CD？」、「CI/CD 如何做？」以及「常見的 CI/CD 工具」，您可以透過右側選單快速跳轉至感興趣的章節。內容會比較初淺，請小心服用。 歡迎給予任何反饋和指正～ ","date":"2022-02-13","objectID":"/cicd-intro/:1:0","tags":["cicd","devops"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-intro/"},{"categories":["DevOps"],"content":"什麼是 CI/CD？ CI/CD cycleCI/CD cycle \" CI/CD cycle 敏捷式軟體開發生命週期中，從開發、測試到部署是一系列持續迭代的過程，CI/CD 指的是持續整合和持續交付或持續部署的組合實踐。CI/CD通過在應用程式的構建、測試和部署中實施自動化，在開發和運營團隊之間架起了橋梁。 ","date":"2022-02-13","objectID":"/cicd-intro/:2:0","tags":["cicd","devops"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-intro/"},{"categories":["DevOps"],"content":"CI 持續整合 (Continuous Integration) 每當開發人員 push 程式碼變更到 remote repository 時，觸發自動化 build 和 test 的程序，確保這次的變更是符合規範且通過所有測試案例的，減少有問題的程式碼影響到生產環境的機會。 ","date":"2022-02-13","objectID":"/cicd-intro/:2:1","tags":["cicd","devops"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-intro/"},{"categories":["DevOps"],"content":"CD 持續交付 / 持續部署 (Continuous Delivery / Continuous Deployment) 完成 Build 和 Test 的下一步就是程式碼部署啦，而 Continuous Delivery 和 Continuous Deployment 的差別就是人為手動部署和自動化部署而已。 ","date":"2022-02-13","objectID":"/cicd-intro/:2:2","tags":["cicd","devops"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-intro/"},{"categories":["DevOps"],"content":"CI/CD Workflow CI/CD WorkflowCI/CD Workflow \" CI/CD Workflow 從上面這張流程圖的可以看出 CI/CD 主要的工作流：(1)當專案程式碼提交 (commit → push / merge)；(2)進入 CI Pipeline，建立一個測試環境，跑過所有單元測試+整合測試、程式碼規範檢查；(3)進入 CD Pipeline，完成程式碼部署。 CI/CD = 自動化測試 + 自動部署？ 看完前面的介紹，可能會認為 CI/CD 只是寫腳本跑自動化測試 + 自動部署，然而 “Continuous” 的意義是“頻繁地”釋出新版本，降低過大變動帶來的問題與衝突，從 3 個月發佈 1 次，到 1 天發佈 3 次，達到敏捷精神中小步快跑、快速迭代的狀態。 ","date":"2022-02-13","objectID":"/cicd-intro/:2:3","tags":["cicd","devops"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-intro/"},{"categories":["DevOps"],"content":"為什麼要 CI/CD？ 想像一下，上述流程若都交給開發人員手動執行，不僅要花大量操作時間和等待時間，還可能會有人為失誤產生，更何況 CI/CD 要我們頻繁做這些事，導致成本大幅增加。 ","date":"2022-02-13","objectID":"/cicd-intro/:3:0","tags":["cicd","devops"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-intro/"},{"categories":["DevOps"],"content":"CD/CD 的好處 Happiness for Developer (https://stackoverflow.blog/2020/02/27/the-eight-factors-of-happiness-for-developers/)Happiness for Developer \" Happiness for Developer (https://stackoverflow.blog/2020/02/27/the-eight-factors-of-happiness-for-developers/) CI/CD 可以為團隊帶來以下好處，同時也是我們所追求的目標： 避免版本衝突 降低人為操作失誤 減少人工時間花費 及早發現(bug)及早修正(fix) 專注開發提高生產力 加速產品迭代 延伸思考 這些目標其實都不太具體，還需要進一步透過量化指標來評估 CI/CD 成效，有興趣的朋友可參考這篇 衡量和監控 CI/CD 性能。 ","date":"2022-02-13","objectID":"/cicd-intro/:3:1","tags":["cicd","devops"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-intro/"},{"categories":["DevOps"],"content":"CI/CD 如何做？ 為了達到快速又頻繁的新版本發佈，必須要有嚴謹和穩健的流程，從前面的 CI/CD Workflow 可見步驟相當繁瑣且有相依性，因此需要透過工具和指令，有效地自動化幫我們執行這些程序。 ","date":"2022-02-13","objectID":"/cicd-intro/:4:0","tags":["cicd","devops"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-intro/"},{"categories":["DevOps"],"content":"先備知識與技能 做 CI/CD 之前，建議團隊要有一定的成熟度，才能快速將現有的程序轉換為自動化的方式運行，以下是我認為必須先具備的知識和技能，導入 CI/CD 時較能快速上手： Shell Script(Command)：與作業系統 Kernel 互動的語言(指令)是一切的基礎 SSH 連線：創建公鑰和私鑰，以特定使用者連線至遠端 Server 進行操作 Git 版本控制：任何一種 Git workflow，用來管理分支、切換版本、合併流程 容器化技術：用來隔離環境，快速搭建和部署（e.g. docker, docker-compose) 程式碼規範檢查：檢查你的程式碼，是否符合團隊規範的程式碼風格 單元測試、整合測試、自動化測試：檢查你的程式碼，能否在目標環境正常運作 ","date":"2022-02-13","objectID":"/cicd-intro/:4:1","tags":["cicd","devops"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-intro/"},{"categories":["DevOps"],"content":"流程與準備 上述的知識與技能你都已經掌握了之後，開始盤點 CI/CD 各個步驟會用到的指令，接著確認這些指令的順序（哪些具有相依性？哪些可以平行化？） GitLab CI/CD Pipeline(source: https://docs.gitlab.com/ee/ci/pipelines/)\" GitLab CI/CD Pipeline(source: https://docs.gitlab.com/ee/ci/pipelines/) 小建議 先將工作流程的 DAG (Directed Acyclic Graph，有向無環圖)畫出來，然後手動執行一遍所有流程（這時有就能感受到人工做這些事其實相當繁瑣及耗時），下一步就是將相同的程序透過工具自動化執行啦！ ","date":"2022-02-13","objectID":"/cicd-intro/:4:2","tags":["cicd","devops"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-intro/"},{"categories":["DevOps"],"content":"CI/CD 工具 常見的 CI/CD 工具有 Jenkins、GitLab、Circle CI、Travis CI、Drone 等，另外，各大雲端平台(AWS, GCP, Azure)也有推出 CI/CD 解決方案，更好地整合了自家的雲端服務。 Continuous delivery tool landscape(source: http://www.jamesbowman.me/post/continuous-delivery-tool-landscape/Continuous delivery tool landscape \" Continuous delivery tool landscape(source: http://www.jamesbowman.me/post/continuous-delivery-tool-landscape/ 一般我們會希望這些工具通常具備以下功能： 最基本的建立、編輯腳本 相容各 Git 程式碼託管平台 視覺化呈現工作流(Workflow)、狀態(Status)和進度(Progress) 管理不同使用者權限(Maintainer, Developer, Reviewer, etc.) 可將任務分散給多個 Runner / Worker 執行 設定成功 / 失敗發送信件通知 支持第三方工具整合 … Info 我目前團隊用的程式碼託管平台是 GitLab，評估過後發現 GitLab 的 CI/CD 解決方案很棒，因此選用為我們的工具，並開始逐步導入。（之後文章將會介紹使用方式） ","date":"2022-02-13","objectID":"/cicd-intro/:4:3","tags":["cicd","devops"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-intro/"},{"categories":["DevOps"],"content":"總結 好的 CI/CD 可以幫助團隊減少人為失誤，提高生產力，加速產品迭代；壞的 CI/CD 可能會導致流程更加混亂，增加人力除錯成本，造成品質低落。 所以你應該依團隊目前的成熟度，逐步將 CI/CD 各個環節添加進去，不需要一次就全部導入，例如：單元測試尚未落實的團隊，進入 CI 階段前可以先透過 Code Review 檢查；自動部署尚未穩定的團隊，CD 階段可以只做到自動交付，保留最後一步由人工進行部署。 最後，期望團隊今年可以在各大專案中導入，也期許自己保有持續輸出(Continuous Output)、持續分享(Continuous Sharing)的精神XD ","date":"2022-02-13","objectID":"/cicd-intro/:5:0","tags":["cicd","devops"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-intro/"},{"categories":["DevOps"],"content":"參考 https://docs.gitlab.com/ee/ci/ https://www.redhat.com/zh/topics/devops/what-is-ci-cd https://bear-1111.medium.com/什麼是-ci-cd-72bd5ae571f1 https://blog.kennycoder.io/2020/04/07/CI-CD-持續性整合-部署-因為懶，所以更要CI-CD！概念講解！/ ","date":"2022-02-13","objectID":"/cicd-intro/:6:0","tags":["cicd","devops"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-intro/"},{"categories":null,"content":"Works a b c ","date":"2021-10-26","objectID":"/cv/:0:1","tags":null,"title":"CV","uri":"/cv/"},{"categories":null,"content":"Education a b c ","date":"2021-10-26","objectID":"/cv/:0:2","tags":null,"title":"CV","uri":"/cv/"},{"categories":null,"content":"Talks a b c ","date":"2021-10-26","objectID":"/cv/:0:3","tags":null,"title":"CV","uri":"/cv/"},{"categories":null,"content":"Skills a b c ","date":"2021-10-26","objectID":"/cv/:0:4","tags":null,"title":"CV","uri":"/cv/"},{"categories":null,"content":"Special a b c ","date":"2021-10-26","objectID":"/cv/:0:5","tags":null,"title":"CV","uri":"/cv/"},{"categories":null,"content":"Hello 我是 Enzo，一位非典型工程師，跨足資料科學 x 軟體開發 x 資訊教育，熱愛學習與參加社群，目前在某電商平台擔任 Data Engineer (90%)，身兼 Scrum Master (10%)。曾經在接案公司擔任軟體工程師和專案經理，經歷各種隕石需求和合約戰爭荼毒，遇見敏捷(Agile/Scrum)後，深受其價值觀所吸引，致力成為身心合一的敏捷實踐家！ ","date":"2021-10-26","objectID":"/about/:0:1","tags":null,"title":"關於本站","uri":"/about/"},{"categories":null,"content":"架站動機 架設這個部落格的目的是想記錄自己在工作上或日常中的成長歷程，因為我認為學習必須經過自己的整理和輸出，梳理自己對於知識概念的，形成自己的觀點。過去我雖然有在社群媒體發文，但其觸及率極低且無法被搜尋引擎找到，因此，想要建立這個專屬的空間，集中並擴大影響力。 ","date":"2021-10-26","objectID":"/about/:0:2","tags":null,"title":"關於本站","uri":"/about/"},{"categories":null,"content":"文章方向 這個部落格的文章主題會以「 資料工程 Data Engineering 」、「 敏捷 Agile/Scrum 」、「 職涯探索 Career」為主，內容類型可能為學習筆記、實作教學、經驗分享、個人觀點等。 ","date":"2021-10-26","objectID":"/about/:0:3","tags":null,"title":"關於本站","uri":"/about/"},{"categories":null,"content":"行動期許 期許自己能夠堅持寫文，幫助自己也能幫助到別人，也歡迎你與我連結、互相交流。 ","date":"2021-10-26","objectID":"/about/:0:4","tags":null,"title":"關於本站","uri":"/about/"},{"categories":null,"content":"聯繫方式 Facebook：https://www.facebook.com/enzoapu Linkedin：https://www.linkedin.com/in/enzochang E-mail：enzoapu@gmail.com PyData Taipei 2020https://pydata.org/taipei2020/program/talk-14/ \" PyData Taipei 2020 ","date":"2021-10-26","objectID":"/about/:0:5","tags":null,"title":"關於本站","uri":"/about/"}]