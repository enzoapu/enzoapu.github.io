[{"categories":["Career"],"content":"最近在和幾位同事討(推)論(坑)要不要投稿今年的 PyCon APAC，發現大家普遍都缺乏動機（不知道為何要投）或是有點畏懼（沒自信能當講者），不過在我看來，投稿和當講者都是一件 C/P 值很高的事！本篇文章將介紹當講者的好處、一些重要的心態，以及任何人都可以展開行動的方法～","date":"2022-04-10","objectID":"/why-you-should-be-a-conference-speaker/","tags":["conference","speaker","community"],"title":"[CAREER] 為什麼你應該投稿成為社群/研討會講者？","uri":"/why-you-should-be-a-conference-speaker/"},{"categories":["Career"],"content":"前言 最近在和幾位同事討(推)論(坑)要不要投稿今年的 PyCon APAC，發現大家普遍都缺乏動機（不知道為何要投）或是有點畏懼（沒自信能當講者），不過在我看來，投稿和當講者都是一件 C/P 值很高的事！ 本篇文章將介紹當講者的好處、一些重要的心態，以及任何人都可以展開行動的方法～ ","date":"2022-04-10","objectID":"/why-you-should-be-a-conference-speaker/:1:0","tags":["conference","speaker","community"],"title":"[CAREER] 為什麼你應該投稿成為社群/研討會講者？","uri":"/why-you-should-be-a-conference-speaker/"},{"categories":["Career"],"content":"成為講者有什麼好處？ ","date":"2022-04-10","objectID":"/why-you-should-be-a-conference-speaker/:2:0","tags":["conference","speaker","community"],"title":"[CAREER] 為什麼你應該投稿成為社群/研討會講者？","uri":"/why-you-should-be-a-conference-speaker/"},{"categories":["Career"],"content":"之於個人 累積個人品牌 最直覺的好處就是「個人品牌建立」，這對於專業形象和人格特質上都非常加分。想像一下，一位應者者的履歷上有一些演講經歷，可以想像他/她是個挑戰自我且樂於分享的人。 另外，在你未來投稿時，附上大大小小的演講經驗，有助於增加審稿人對你的信任，以獲得更多機會。（特別是大型的年會/研討會蠻看重你過往的演講經驗） 強化知識概念 在你投稿的過程或是準備演講時，會逼迫自己梳理這個主題的知識和概念，組織得更加系統化，這時你可能會發現自己還不熟悉或不清楚的地方，就必須補足認知並加深理解。 訓練演說技巧 為了讓聽眾聽得懂你的專業內容，且在演講後能將收穫帶走，就得花更多努力在準備這場演講，例如把複雜的概念轉化為白話文，將生硬的內容變得生動有趣，找更多實際案例進行說明等。 建立專業人脈 你將獲得跟其他講者、主持人、專家、主辦方認識的機會。一般來說現場的與會者不會去認識其他聽眾，而會選擇在演講後跟講者進行交流，這時候就是在你的專業領域上研討、切磋的好機會。 ","date":"2022-04-10","objectID":"/why-you-should-be-a-conference-speaker/:2:1","tags":["conference","speaker","community"],"title":"[CAREER] 為什麼你應該投稿成為社群/研討會講者？","uri":"/why-you-should-be-a-conference-speaker/"},{"categories":["Career"],"content":"之於團隊 / 公司 經營雇主品牌 近年人才市場競爭激烈，越來越多公司意識到「雇主品牌」的重要性，開始投注資源在社群經營以及文化塑造上，因此，你出去演講等同於替公司/團隊進行一次宣傳，畢竟你不是人力資源單位或是公關部門，你所代表的是產品或開發團隊透明、真實的展現。 被動招募人才 承接上一點，身為一名求職者，看到這間企業的員工很常在社群/研討會演講，就能想像這裡是鼓勵學習、樂於分享、強者如雲的，如果你剛好渴望在這種環境下成長、共事，自然會提高你應徵的意願。 如果你的演講題目是基於工作上的專案或產品，提到其應用場景、系統架構、角色分工，以及使用的技術和工具等，這些資訊對潛在的應徵者來說也非常重要，遠比招募頁面刊登的職務描述(Job Description)更有效果，無形之中吸引到志同道合的夥伴加入。 ","date":"2022-04-10","objectID":"/why-you-should-be-a-conference-speaker/:2:2","tags":["conference","speaker","community"],"title":"[CAREER] 為什麼你應該投稿成為社群/研討會講者？","uri":"/why-you-should-be-a-conference-speaker/"},{"categories":["Career"],"content":"成為講者之心態建立 你其實不一定要很厲害 下這標題可能會不小心冒犯到很多大大XD（我絕對肯定能成為講者絕對是有實力且認真準備的人） 但我想強調的是「你不用是領域大神或是技術專家才能成為講者」，因為「你的演講還是會幫助到比你資淺的人」，知識實在太深太廣，人可用的時間卻相當有限，沒有人能精通所有的技能，因此，你的題目可能就是別人還沒研究的那部分。（講者有責任確保內容的正確性） 假設經驗值分為 0 ~ 10 分，你端出 5分的題目，雖然滿足不了 6 ~ 10 分的人，但對於 0 ~ 4 分的人來說還是很有收穫。所以，現在很多研討會都有將稿件分級，依照你的內容設定目標聽眾為「無相關經驗或想要學習入門」或「已有基礎並想進一步了解」或「進階使用＆深入研討」等；與會者也會照自己的程度選擇合適的議程。（講者有責任確保內容沒有誇大不實） 到處都是機會，只要你有意願 看到這你已經知道成為講者的好處，也許還增加了一點信心，不過仍然覺得自己離研討會太遙遠，該怎麼辦呢？ 不用擔心，其實這很正常～ 對於不常上台發表或分享的人來說，確實有一定的心理門檻要跨過。 我們可以把目標拉近一點，閃電秀(Lightning Talk)或社群聚會(Meetup)是負擔較輕的方式，這種時數短或規模小的形式，很適合作為練習的場合。 還是很有難度嗎？ 那我最推薦的方式是「從團隊內部開始」，不論是工作的同事或是社群的夥伴，組成小型的分享會/讀書會，大家都是自己人，講錯或卡詞也不會怎樣，重要的是準備過程中的成長和獲得反饋改進的機會！ 尊重授權、適當保密 在開源的盛行的時代，很容易就能取得別人的投影片或程式碼，就會是個人發起的專案(side project)也很可能是基於他人的源碼和套件，因此需要注意開源授權(Open Source License)規範，簡報中的素材若是直接複製或二次創作的都應該有意識地使用。 若你要投稿的題目是工作上的專案或是產品，內容可能涉及商業利益或競業關係，因此應當要謹慎拿捏範圍，符合公司的保密規範，無法公開的數據或機敏資訊都得迴避（抽象化、去識別）。 我的建議是主動告知你的主管，並說明詳細內容、範圍以及可能的風險；若專案/產品有其他人主要參與其中，也建議知會他/她們一聲，因為這不是一個人的成果，而是你們共同的努力～ ","date":"2022-04-10","objectID":"/why-you-should-be-a-conference-speaker/:3:0","tags":["conference","speaker","community"],"title":"[CAREER] 為什麼你應該投稿成為社群/研討會講者？","uri":"/why-you-should-be-a-conference-speaker/"},{"categories":["Career"],"content":"要如何展開行動 你已經決定要投稿、成為講者了嗎？ 以下將介紹你可以展開哪些行動，以及如何提高綠取率的方法。 ","date":"2022-04-10","objectID":"/why-you-should-be-a-conference-speaker/:4:0","tags":["conference","speaker","community"],"title":"[CAREER] 為什麼你應該投稿成為社群/研討會講者？","uri":"/why-you-should-be-a-conference-speaker/"},{"categories":["Career"],"content":"市場調查 開始尋找在你的專業領域上，有哪些社群、研討會或年會，其徵稿規範、舉辦日期、進行方式、規模大小、參與人數、潛在影響力、收費方式、歷屆 Keynote speakers、目標聽眾對象等，從各種你所在意或專注的點來選擇要投稿的對象。 ","date":"2022-04-10","objectID":"/why-you-should-be-a-conference-speaker/:4:1","tags":["conference","speaker","community"],"title":"[CAREER] 為什麼你應該投稿成為社群/研討會講者？","uri":"/why-you-should-be-a-conference-speaker/"},{"categories":["Career"],"content":"跟自己對話 你要清楚的知道自己想分享的題目是什麼，也得讓審稿委員明白你的題目符合目標聽眾的需求。 以今年 PyCon APAC 為例，官方有提供很棒的提示引導。 下面的內容將會幫助您成功地送出一份投稿。我們將會提供一些訣竅使得您的投稿資訊更加完整豐富且具吸引力，並有更高的機率通過審稿。從大方向來說，在投稿之前將從下面幾個方面與問題展開您的思路： 投稿的主題是？ 誰是您的目標觀眾群？ 聽眾群在演講後能得到什麼收穫？ 如何在時間限制內組識這演講？ ","date":"2022-04-10","objectID":"/why-you-should-be-a-conference-speaker/:4:2","tags":["conference","speaker","community"],"title":"[CAREER] 為什麼你應該投稿成為社群/研討會講者？","uri":"/why-you-should-be-a-conference-speaker/"},{"categories":["Career"],"content":"用心說明投稿內容 相較於只需要填寫「題目」、「大綱」、「描述」的情況，我更希望主辦單位提供更細緻的欄位要求，因為這樣才能幫助講者反思和梳理，也讓審稿人獲得完成的資訊，使得雙方的認知更加透明、對齊。 因此，我建議就算系統上沒有要求你填寫那麼多欄位，你也要想辦法利用格式（分段落）去描述你的投稿內容。這部分我同樣推薦參考 PyCon 的欄位說明： 摘要 介紹整個演講的主軸。如果演講有需要特別的背景知識（domain knowledge），應為單一段落。 演講目標 你的目標聽眾是誰？聽完之後能從這演講中得到什麼？當他們離開了演講廳後，有沒有學到什麼以前不知道的？ 詳細說明 本欄位太長可能會嚇到審查員或者潛在的聽眾（長度不會超過 1200 個中文字）。由於多數的審查員不一定如你這麼了解投稿的主題，可以把與主題相關的文章連結加至此欄位。 大綱 本演講的進行將會如何安排。列舉講題的子項目與各項目預計的時間長度。 補充資訊 任何你想讓審查員或議程組在決定稿件時知道的訊息，包括：過去的演講經驗、社群經驗等。 ","date":"2022-04-10","objectID":"/why-you-should-be-a-conference-speaker/:4:3","tags":["conference","speaker","community"],"title":"[CAREER] 為什麼你應該投稿成為社群/研討會講者？","uri":"/why-you-should-be-a-conference-speaker/"},{"categories":["Career"],"content":"參考歷屆演講題目 不知道自己的主題適不適合拿來投稿嗎？ 你可以先去瀏覽這個研討會歷年的演講（通常官網都找得到），公開的題目都是有通過審查的，所以你可以抓到什麼樣的內容可能受到青睞，什麼樣的格式讓人清楚易懂。 如果你發現你想投稿的題目過去很少見，這可能是個好機會！審稿委員因為題目創新或資源較少為你加分；但也可能是風險！會不會是這題目跟研討會主軸不相關，或是切入點不符合聽眾的期待呢？ 從歷屆演講題目可以得到許多有趣的發現或靈感，多多少少能夠參考，但也別被這些內容限制了，不如走出自己的風格吧～ ","date":"2022-04-10","objectID":"/why-you-should-be-a-conference-speaker/:4:4","tags":["conference","speaker","community"],"title":"[CAREER] 為什麼你應該投稿成為社群/研討會講者？","uri":"/why-you-should-be-a-conference-speaker/"},{"categories":["Career"],"content":"總結 最後，我想説投稿不用錢，投稿的成本沒有那麼高，或許花個一天就能完成（錄取後是另一件事），倘若有機會成為講者的效益卻非常高，鼓勵大家都可以嘗試挑戰，這過程同時是檢視自己的好機會；如果社群/研討會的講者還離你太遠，就從下禮拜的部門/團隊內部分享開始吧！！！ 以上屬於我的個人觀點，歡迎讀者留言或是私訊與我交流想法～～～ 文章轉發請幫我註明出處，感謝您！ ","date":"2022-04-10","objectID":"/why-you-should-be-a-conference-speaker/:5:0","tags":["conference","speaker","community"],"title":"[CAREER] 為什麼你應該投稿成為社群/研討會講者？","uri":"/why-you-should-be-a-conference-speaker/"},{"categories":["Data Engineering"],"content":"上一篇文章我們已經把 RabbitMQ Server 的環境架設起來，並在網頁管理介面上體驗建立 Queue 和 Publish / Get 訊息，系列文的最後一篇終於要來寫 code 了，我們將使用 Python 的 Library - Pika 與 RabbitMQ 進行互動，撰寫 Client 端的 Producer 和 Consumer 程式碼。","date":"2022-03-22","objectID":"/rabbitmq-python-example/","tags":["rabbitmq","python","pika"],"title":"[DATA] 訊息佇列 04 - RabbitMQ x Python 程式實作範例","uri":"/rabbitmq-python-example/"},{"categories":["Data Engineering"],"content":"前言 上一篇文章我們已經把 RabbitMQ Server 的環境架設起來，並在網頁管理介面上體驗建立 Queue 和 Publish / Get 訊息，系列文的最後一篇終於要來寫 code 了，我們將使用 Python 的 Library - Pika 與 RabbitMQ 進行互動，撰寫 Client 端的 Producer 和 Consumer 程式碼。 [ 系列文章目錄 ] [DATA] 訊息佇列 01 - Message Queue 介紹與實際應用 [DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式 [DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面 [DATA] 訊息佇列 04 - RabbitMQ x Python 程式實作範例（本篇） ","date":"2022-03-22","objectID":"/rabbitmq-python-example/:1:0","tags":["rabbitmq","python","pika"],"title":"[DATA] 訊息佇列 04 - RabbitMQ x Python 程式實作範例","uri":"/rabbitmq-python-example/"},{"categories":["Data Engineering"],"content":"RabbitMQ Clients \u0026 Server 上一篇我們透過 Docker 來運行 RabbitMQ Server，也就是 Producer - Broker - Consumer 架構中的 Broker；現在我們要來實作 RabbitMQ Clients，包含推送訊息的 Producer 和消化訊息的 Consumer。 RabbitMQ Clients and Server\" RabbitMQ Clients and Server RabbitMQ Clients 有許多官方支持的 Libraries and Develoer Tools，可根據你熟悉的程式語言做選擇，本文將使用 pure-Python 的 Library: Pika ","date":"2022-03-22","objectID":"/rabbitmq-python-example/:2:0","tags":["rabbitmq","python","pika"],"title":"[DATA] 訊息佇列 04 - RabbitMQ x Python 程式實作範例","uri":"/rabbitmq-python-example/"},{"categories":["Data Engineering"],"content":"RabbitMQ Client Library (Python) - Pika ","date":"2022-03-22","objectID":"/rabbitmq-python-example/:3:0","tags":["rabbitmq","python","pika"],"title":"[DATA] 訊息佇列 04 - RabbitMQ x Python 程式實作範例","uri":"/rabbitmq-python-example/"},{"categories":["Data Engineering"],"content":"Introduction Pika 是一個純 Python 開發的 RabbitMQ 函式庫 [ source code ] [ document ] 使用 AMQP 0-9-1 protocol 支援 Python 2.7 and 3.4+ 版 ","date":"2022-03-22","objectID":"/rabbitmq-python-example/:3:1","tags":["rabbitmq","python","pika"],"title":"[DATA] 訊息佇列 04 - RabbitMQ x Python 程式實作範例","uri":"/rabbitmq-python-example/"},{"categories":["Data Engineering"],"content":"Installation 使用 PyPI 就可以簡單安裝 Pika。 pip install pika Asynchronous pika aio-pika 是使用 asyncio 的異步(Asynchronous)版的 RabbitMQ 函式庫 [ source code ] [ document ] 同樣使用 PyPI 安裝：pip install aio-pika ","date":"2022-03-22","objectID":"/rabbitmq-python-example/:3:2","tags":["rabbitmq","python","pika"],"title":"[DATA] 訊息佇列 04 - RabbitMQ x Python 程式實作範例","uri":"/rabbitmq-python-example/"},{"categories":["Data Engineering"],"content":"Development 建立連線(Connetion \u0026 Channel) 與自己本機(localhost)架設的 RabbitMQ 建立連線（5672 port），使用之前建設定的帳號密碼，得到一個連線(connection)的通道(channel)。 接下來大部分的操作都是在通道(channel)上進行，包括宣告 Queue、定義 Exchange、绑定 Queue 與 Exchange、發佈/接收訊息等。 import pika credentials = pika.PlainCredentials('root', '1234') parameters = pika.ConnectionParameters(host='localhost', port=5672, credentials=credentials) connection = pika.BlockingConnection(parameters) channel = connection.channel() Connection 與 Channel 的差別為何？ Connection 是應用程式與 Broker 的真實 TCP 連接，Channel 則是其中的一個虛擬連接（AMQP），我們可以在應用程式中使用任意數量的虛擬連接（Channel），而不會因過多 TCP 連接（Connection）而導致 Broker 過載。 一般來說可以使用一個 Channel 來處理所有事情，但如果你有多個線程(multiple threads)，建議為每個線程使用不同的 Channel。 更多詳細介紹可參考這篇：RabbitMQ and relationship between channel and connection 生產者(Producer) 首先宣告名稱為 hello 的 Queue（若不存在則會創建），接著對 Queue 發佈一則訊息 Hello World!，最後記得要關閉(close)連線。 在 RabbitMQ 中，訊息不能直接發送到 Queue，而必須經過一個 Exchange，本範例使用空字串 exchange，並使用與 Queue 名稱相同的 routing_key 綁定。 channel.queue_declare(queue='hello') # channel.queue_declare(queue=‘hello’, passive=False, durable=False, exclusive=False, auto_delete=False msg = 'Hello World!' channel.basic_publish(exchange='', routing_key='hello', body=msg) print(f\" [x] Sent '{msg}'\") # [x] Sent 'Hello World!' connection.close() 消費者(Consumer) 首先同樣是宣告名稱為 hello 的 Queue（必須與 Producer 的相同），接著從 Queue 裡取出訊息，確認訊息處理完要 ack，告知 Queue 可拋棄訊息；反之，訊息處理不如預期要 nack，訊息將再次回到 Queue。 訊息確認機制 Acknowledgements 是一種用於傳遞和處理確認的機制，當 RabbitMQ 向 Consumer 傳遞訊息時，它需要知道訊息是否發送成功，透過 method.delivery_tag 標記識別訊息。 channel.basic_ack(method.delivery_tag) 用於肯定確認 channel.basic_nack(method.delivery_tag) 用於否定確認 另外 consume 訊息的方法中，可以帶 auto_ack=True 參數，意即訊息取出後就自動肯定確認。 更多詳細介紹可參考這篇：Consumer Acknowledgements and Publisher Confirms Pika 提供三種從 RabbitMQ Broker 消費(consume)訊息的方法： 1. Using channel.basic_get() to consume a message 使用 basic_get() 方法，每次取出一則訊息，需要開發者手動調用。 channel.queue_declare(queue='hello') channel.basic_get(queue='hello', auto_ack=True) method, properties, body = channel.basic_get(queue='hello', auto_ack=True) print(f\" [x] Received {body.decode()}\") # channel.basic_ack(method.delivery_tag) connection.close() 2. Using channel.basic_consume() to consume messages 使用 basic_consume 方法，指定收到訊息的 callback function，channel.start_consuming() 後就會持續監聽 Queue，直到手動關閉(stop)。 channel.queue_declare(queue='hello') def callback(ch, method, properties, body): print(f\" [x] Received {body.decode()}\") # channel.basic_ack(method.delivery_tag) channel.basic_consume(queue='hello', auto_ack=True, on_message_callback=callback) print(' [*] Waiting for messages. To exit press CTRL+C') channel.start_consuming() try: channel.start_consuming() except KeyboardInterrupt: channel.stop_consuming() connection.close() 3. Using channel.consume() generator to consume messages consume 方法會返回生成器(generator)，用 for loop 迭代取出訊息；若 Consumer 與 Queue 沒有活動(訊息傳遞)的狀態持續 inactivity_timeout 秒，將會收到 method, properties \u0026 body 皆等於 None。 channel.queue_declare(queue='hello') for method, properties, body in channel.consume(queue='hello', auto_ack=True, inactivity_timeout=10): print(f\" [x] Received {body.decode()}\") # channel.basic_ack(method.delivery_tag) if method == None and properties == None and body == None: break connection.close() 完整程式碼 producer.py Producer 發佈 100 則訊息（字串 0 ~ 99）至名稱叫 hello 的 Queue。 import pika credentials = pika.PlainCredentials('root', '1234') parameters = pika.ConnectionParameters(host='localhost', port=5672, credentials=credentials) connection = pika.BlockingConnection(parameters) channel = connection.channel() channel.queue_declare(queue='hello') for i in range(100): msg = str(i) channel.basic_publish(exchange='', routing_key='hello', body=msg) print(f\" [x] Sent '{msg}'\") connection.close() consumer.py Consumer 從 Queue 裡取出訊息，每次取出一筆，在 callback function 打印出內容。 import pika credentials = pika.PlainCredentials('root', '1234') parameters = pika.ConnectionParameters(host='localhost', port=5672, credentials=credentials) connection = pika.BlockingConnection(parameters) channel = connection.channel() channel.queue_declare(queue","date":"2022-03-22","objectID":"/rabbitmq-python-example/:3:3","tags":["rabbitmq","python","pika"],"title":"[DATA] 訊息佇列 04 - RabbitMQ x Python 程式實作範例","uri":"/rabbitmq-python-example/"},{"categories":["Data Engineering"],"content":"系列文總結 訊息佇列系列文終於寫完了，從介紹 Message Queue 是什麼開始，接著進入 RabbirMQ 簡介與設計模式，再到 RabbirMQ 架設和 Web UI 介紹，最後這篇是撰寫 Python 程式實作範例，其實還想補充更多我在專案中用到的一些技巧，不過就先放在心上吧～ 讀者若有其他想知道的部分，或是實作上遇到的問題，可以在底下留言或聯繫告訴我！ 本系列完結。 ","date":"2022-03-22","objectID":"/rabbitmq-python-example/:4:0","tags":["rabbitmq","python","pika"],"title":"[DATA] 訊息佇列 04 - RabbitMQ x Python 程式實作範例","uri":"/rabbitmq-python-example/"},{"categories":["Data Engineering"],"content":"參考 https://pika.readthedocs.io/en/stable/modules/index.html https://pika.readthedocs.io/en/stable/examples.html ","date":"2022-03-22","objectID":"/rabbitmq-python-example/:5:0","tags":["rabbitmq","python","pika"],"title":"[DATA] 訊息佇列 04 - RabbitMQ x Python 程式實作範例","uri":"/rabbitmq-python-example/"},{"categories":["Data Engineering"],"content":"上一篇介紹完 RabbitMQ 的架構和設計模式，接下來就要告訴大家如何自己搭建 RabbitMQ Server，不用幾行指令就可以在本機或是虛擬主機把服務架起來，還提供了一個 Web 管理介面方便你瀏覽和操作。","date":"2022-03-15","objectID":"/rabbitmq-management-interface/","tags":["rabbitmq","web-user-interface","docker"],"title":"[DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面","uri":"/rabbitmq-management-interface/"},{"categories":["Data Engineering"],"content":"前言 上一篇介紹完 RabbitMQ 的架構和設計模式，接下來就要告訴大家如何自己搭建 RabbitMQ Server，不用幾行指令就可以在你本機或是虛擬主機把服務架起來，還提供了一個 Web 管理介面方便你瀏覽和操作。 [ 系列文章目錄 ] [DATA] 訊息佇列 01 - Message Queue 介紹與實際應用 [DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式 [DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面（本篇） [DATA] 訊息佇列 04 - RabbitMQ x Python 程式實作範例 ","date":"2022-03-15","objectID":"/rabbitmq-management-interface/:1:0","tags":["rabbitmq","web-user-interface","docker"],"title":"[DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面","uri":"/rabbitmq-management-interface/"},{"categories":["Data Engineering"],"content":"RabbitMQ 環境架設 RabbitMQ 官方有提供 RabbitMQ Server 在不同作業系統(Linux, MacOS \u0026 Windows)上的安裝指南，不過我還是推薦使用 Docker / Docker Compose 建立環境最為簡單、快速。 ","date":"2022-03-15","objectID":"/rabbitmq-management-interface/:2:0","tags":["rabbitmq","web-user-interface","docker"],"title":"[DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面","uri":"/rabbitmq-management-interface/"},{"categories":["Data Engineering"],"content":"使用 Docker 指令 # create and start container docker run --rm --name rabbitmq -p 5672:5672 -p 15672:15672 \\ -e RABBITMQ_DEFAULT_USER=root -e RABBITMQ_DEFAULT_PASS=1234 rabbitmq:management 指令 \u0026 參數 定義說明 docker run 執行容器 --rm 當容器終止時會自動刪除 --name rabbitmq 將容器命名為 rabbitmq -p 5672:5672 將本機端的 5672 port 關聯到容器的 5672 port（RabbitMQ） -p 15672:15672 將本機端的 15672 port 關聯到容器的 15672 port（Web UI） -e RABBITMQ_DEFAULT_USER=root 宣告環境變數，連線到 RabbitMQ 的 username -e RABBITMQ_DEFAULT_PASS=1234 宣告環境變數，連線到 RabbitMQ 的 password rabbitmq:management 指定容器抓 Docker Hub 上的 RabbitMQ Official Omage docker image version 預設為最新版本(3.9)，若想要指定版本可以替換標籤(tag)，例：rabbitmq:3.8-management 為 3.8 版 ","date":"2022-03-15","objectID":"/rabbitmq-management-interface/:2:1","tags":["rabbitmq","web-user-interface","docker"],"title":"[DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面","uri":"/rabbitmq-management-interface/"},{"categories":["Data Engineering"],"content":"使用 Docker Compose 指令 # create and start container docker-compose -f docker-compose.yml up docker-compose.yml 的參數定義與 Docker 指令完全一致。 # docker-compose.ymlservices:rabbitmq:image:rabbitmq:managementcontainer_name:rabbitmqports:- 5672:5672- 15672:15672environment:- RABBITMQ_DEFAULT_USER=root- RABBITMQ_DEFAULT_PASS=1234 ","date":"2022-03-15","objectID":"/rabbitmq-management-interface/:2:2","tags":["rabbitmq","web-user-interface","docker"],"title":"[DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面","uri":"/rabbitmq-management-interface/"},{"categories":["Data Engineering"],"content":"進入 RabbitMQ 將 RabbitMQ 啟動後，在瀏覽器 http://localhost:15672 進入 RabbitMQ 網頁管理介面，如果能成功進入「登入頁面」，代表 RabbitMQ 已經成功在本機(localhost)架設起來了！ RabbitMQ Web UI - LoginRabbitMQ Web UI - Login \" RabbitMQ Web UI - Login 公開存取 如果你是架設在伺服器或虛擬主機上，只要開啟防火牆 TCP 15672 port，其他人就可以透過 Public IP 進入你的 RabbitMQ 網頁管理介面 http://\u003cyour_puclic_ip_address\u003e:15672 ","date":"2022-03-15","objectID":"/rabbitmq-management-interface/:2:3","tags":["rabbitmq","web-user-interface","docker"],"title":"[DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面","uri":"/rabbitmq-management-interface/"},{"categories":["Data Engineering"],"content":"RabbitMQ 網頁管理介面 rabbitmq:management 這個 Docker Image 有包含 Web 版管理介面，供開發/維運人員透過查看 Queues 的狀態，並可以直接在上面操作，推送(publish)訊息和取出(get)訊息。以下將分別介紹 RabbitMQ 網頁管理介面的主要頁籤功能： ","date":"2022-03-15","objectID":"/rabbitmq-management-interface/:3:0","tags":["rabbitmq","web-user-interface","docker"],"title":"[DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面","uri":"/rabbitmq-management-interface/"},{"categories":["Data Engineering"],"content":"Overview 輸入剛剛設定的 RABBITMQ_DEFAULT_USER 和 RABBITMQ_DEFAULT_PASS 登入後，就會進入「總覽頁面」，顯示 RabbitMQ Server 上的重要資訊和指標。 RabbitMQ Web UI - OverviewRabbitMQ Web UI - Overview \" RabbitMQ Web UI - Overview ","date":"2022-03-15","objectID":"/rabbitmq-management-interface/:3:1","tags":["rabbitmq","web-user-interface","docker"],"title":"[DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面","uri":"/rabbitmq-management-interface/"},{"categories":["Data Engineering"],"content":"Connections 顯示目前 RabbitMQ Server 上所有 Clients 的連線狀態與網路資訊。 RabbitMQ Web UI - ConnectionsRabbitMQ Web UI - Connections \" RabbitMQ Web UI - Connections ","date":"2022-03-15","objectID":"/rabbitmq-management-interface/:3:2","tags":["rabbitmq","web-user-interface","docker"],"title":"[DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面","uri":"/rabbitmq-management-interface/"},{"categories":["Data Engineering"],"content":"Channels 顯示目前 RabbitMQ Server 上所有 Channels 的訊息吞吐量。 RabbitMQ Web UI - ChannelsRabbitMQ Web UI - Channels \" RabbitMQ Web UI - Channels ","date":"2022-03-15","objectID":"/rabbitmq-management-interface/:3:3","tags":["rabbitmq","web-user-interface","docker"],"title":"[DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面","uri":"/rabbitmq-management-interface/"},{"categories":["Data Engineering"],"content":"Exchanges 查看並管理 Exchanges，預設已經建立了幾種不同 Type 的 Exchanges，可以直接使用或是自行手動新增。 RabbitMQ Web UI - ExchangesRabbitMQ Web UI - Exchanges \" RabbitMQ Web UI - Exchanges ","date":"2022-03-15","objectID":"/rabbitmq-management-interface/:3:4","tags":["rabbitmq","web-user-interface","docker"],"title":"[DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面","uri":"/rabbitmq-management-interface/"},{"categories":["Data Engineering"],"content":"Queues 查看並管理每一條 Queue 的訊息(messages)狀態與吞吐量。 RabbitMQ Web UI - QueuesRabbitMQ Web UI - Queues \" RabbitMQ Web UI - Queues 新增 Queue 輸入自訂 \u0008Queue name（唯一值），並設定必要及可選的參數。 Add QueueAdd Queue \" Add Queue Durablity Durable 在 RabbitMQ 關閉/重啟後訊息還會留存；Transient 在 RabbitMQ 關閉/重啟後就不存在了。 Auto delete 若選 Yes，Queue 會在所有 Consumer 都中斷連接時自行刪除。 Aruguments Message TTL：Queue 裡的訊息在多少時間（毫秒）內若沒有被取用就會被丟棄 Auto expire：Queue 在多少時間（毫秒）內若都沒有被使用就會自動刪除 Single active connsumer：這條 Queue 是否只能有一個存活的 Consumer Max length：Queue 最多保存的訊息量，若超過會從頭端（FIFO）丟棄訊息 Max length bytes：Queue 最多保存的訊息長度，若超過會從頭端（FIFO）丟棄訊息 訊息長度限制 若 Max length 為 1000，單一訊息 12 bytes，代表 Queue 最多能保存 1000 則訊息； 若 Max length bytes 為 10000，單一訊息 12 bytes，代表最多只能存 10000/12=833 則訊息 Queue 的訊息可能會因為過期（MMessage TTL）或超過限制（Max length）被丟棄，透過以下兩個 Arguments 設定這些訊息要被重新推送至哪裡。 Dead letteer exchange：被丟棄的訊息要被推送進入的 Exchange Dead letteer routing key：\u0008Dead letteer exchange 要綁定(binding) Queue 的 Routing key 管理 Queue 點選上面建立的 test-ueue 進入 Queue 內容頁面，在這裡可以： 查看 Messages 的詳細資訊和速率指標 設定 Queue 要綁定(binding)的 Exchange 和 Routing key 查看連接的 Consumer(s) 推送訊息、取出一至多則訊息 刪除(delete)整條 Queue 清空(purge)整條 Queue 裡的訊息 透過程式碼管理 Queue 雖然在網頁介面上都完成上述操作，但其實對於開發者來說，只要寫程式也能夠簡單地做到，下一篇文章會介紹 RabbitMQ x Python 的實作範例。 Publish / Get message 你可以在介面上試著推送(Publish)訊息，再取出(Get)訊息，你將依序地得到這些訊息。 Publish / Get messagePublish / Get message \" Publish / Get message 測試的同時你可觀察訊息圖表的即時變化。（網頁預設 Refresh every 5 seconds） Queue OverviewQueue Overview \" Queue Overview ","date":"2022-03-15","objectID":"/rabbitmq-management-interface/:3:5","tags":["rabbitmq","web-user-interface","docker"],"title":"[DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面","uri":"/rabbitmq-management-interface/"},{"categories":["Data Engineering"],"content":"Admin 最初使用的 DEFAULT 帳密是最高權限使用者，若想把帳號分給其他人，可在這個頁面管理 Users 或新增 User。 RabbitMQ Web UI - AdminRabbitMQ Web UI - Admin \" RabbitMQ Web UI - Admin ","date":"2022-03-15","objectID":"/rabbitmq-management-interface/:3:6","tags":["rabbitmq","web-user-interface","docker"],"title":"[DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面","uri":"/rabbitmq-management-interface/"},{"categories":["Data Engineering"],"content":"參考 https://www.rabbitmq.com/queues.html https://kucw.github.io/blog/2020/11/rabbitmq/ https://godleon.github.io/blog/ChatOps/message-queue-concepts/ ","date":"2022-03-15","objectID":"/rabbitmq-management-interface/:4:0","tags":["rabbitmq","web-user-interface","docker"],"title":"[DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面","uri":"/rabbitmq-management-interface/"},{"categories":["Data Engineering"],"content":"上一篇文章介紹完 Message Queue 是什麼後，這次要介紹的是知名且易用的實作工具 RabbitMQ，本篇文章將帶大家認識 RabbitMQ 的架構以及 5 種設計模式。","date":"2022-03-06","objectID":"/rabbitmq-introduction/","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式","uri":"/rabbitmq-introduction/"},{"categories":["Data Engineering"],"content":"前言 上一篇文章介紹完 Message Queue 是什麼後，這次要介紹的是知名且易用的實作工具 RabbitMQ，本篇文章將帶大家認識 RabbitMQ 的架構以及 5 種設計模式。 [ 系列文章目錄 ] [DATA] 訊息佇列 01 - Message Queue 介紹與實際應用 [DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式（本篇） [DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面 [DATA] 訊息佇列 04 - RabbitMQ x Python 程式實作範例 ","date":"2022-03-06","objectID":"/rabbitmq-introduction/:1:0","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式","uri":"/rabbitmq-introduction/"},{"categories":["Data Engineering"],"content":"RabbitMQ 簡介 RabbitMQ 是使用廣泛的輕量級開源工具，支持 AMQP 0-9-1 等多種訊息傳遞協定。 RabbitMQ 容易在本地端和雲端部署，滿足大規模(分散式)、高可用性的需求。 RabbitMQ 為大多數流行的程式語言提供了多樣的開發套件包。(Python, Java, Ruby, PHP, C#, JS, Go, etc.) RabbitMQ 提供了一個 Web 使用者介面來管理權限並監控各種狀態、指標。 ","date":"2022-03-06","objectID":"/rabbitmq-introduction/:2:0","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式","uri":"/rabbitmq-introduction/"},{"categories":["Data Engineering"],"content":"RabbitMQ 架構 RabbitMQ ArchitectureRabbitMQ Architecture \" RabbitMQ Architecture 看完上一篇我們已經知道 Message Queue 架構中的三個角色，在 RabbitMQ 中也延用相同概念： Producer 是發送訊息的應用程式 Queue 是儲存訊息的緩衝區 Consumer 是接收訊息的應用程式 不過在 RabbitMQ 中，根據不同設計模式會在 Producer 與 Queue 之間加上一層 Exchange： Exchange 的工作很簡單，透過綁定(binding)與 Queue 連結，負責接收來自 Producer 的訊息，然後將訊息推送給 Queue。 透過定義 Exchange 的類型(type)來判斷要如何處理收到的訊息，是要推送給哪個特定 Queue？還是要推送給多個 Queue？或是應該被丟棄？ Exchange 的類型(type)有分為 direct, topic \u0026 fanout，文章下個段落介紹不同模式時會探討差別。 RabbitMQ Exchange TypesRabbitMQ Exchange Types \" RabbitMQ Exchange Types -- ","date":"2022-03-06","objectID":"/rabbitmq-introduction/:3:0","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式","uri":"/rabbitmq-introduction/"},{"categories":["Data Engineering"],"content":"RabbitMQ 設計模式 根據 RabbitMQ Tutorials 官方的範例，展示了五種常見的模式（Python 範例程式碼附在標題後方連結）： ","date":"2022-03-06","objectID":"/rabbitmq-introduction/:4:0","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式","uri":"/rabbitmq-introduction/"},{"categories":["Data Engineering"],"content":"1. Simple 模式 The simplest thing that does something (sample code) RabbitMQ - Simple\" RabbitMQ - Simple 最基本的一種模式，只有一個 Queue(定義 Queue 的名稱)，Producer 直接將訊息傳進這個 Queue(hello)，也只有一個 Consumer 從這個 Queue(hello) 取出訊息。 ","date":"2022-03-06","objectID":"/rabbitmq-introduction/:4:1","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式","uri":"/rabbitmq-introduction/"},{"categories":["Data Engineering"],"content":"2. Worker 模式 Distributing tasks among workers (sample code) RabbitMQ - Worker\" RabbitMQ - Worker 相比 Simple，Worker 模式會有兩個以上的 Consumer(Worker)，從同一個 Queue 取出訊息，且 Consumer 彼此間不會取得相同的訊息，加速訊息處理(消化)速度。因此只要連接同一個 Queue，就可以在多台機器上 Consumer 平行處理。 。 預取數量(prefetch count) 可透過 prefetch_count 參數，控制每個 Consumer(Worker) 每一次取出的訊息數量，假設 Producer 將 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 依序傳進 Queue： 在 prefetch_count = 1 的情況 C1 依序取出 1、3、5、7、9 (共五次) C2 依序取出 2、4、6、8、10 (共五次) 在 prefetch_count = 2 的情況 C1 依序取出 1,2、5,6、9,10 (共三次) C2 依序取出 3,4、7,8(共兩次) ","date":"2022-03-06","objectID":"/rabbitmq-introduction/:4:2","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式","uri":"/rabbitmq-introduction/"},{"categories":["Data Engineering"],"content":"3. Publish/Subscribe 模式 Sending messages to many consumers at once (sample code) RabbitMQ - Publish/Subscribe\" RabbitMQ - Publish/Subscribe Publish/Subscribe 模式顧名思義，就像你訂閱某個 YT 頻道，當頻道創作者發佈了新影片，連同你的所有訂閱者都會收到通知。 Producer 不會將訊息直接傳進 Queue，而是交給 Exchange (type=fanout)，由於 fanout 的特性，Exchange 會把訊息廣播給所有綁定的 Queue，每個 Consumer 就會接收到相同的訊息。因此當有另外的系統需要同步接收訊息，只需增加一組 Queue + Producer，綁定這個 Exchange 即可。 ","date":"2022-03-06","objectID":"/rabbitmq-introduction/:4:3","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式","uri":"/rabbitmq-introduction/"},{"categories":["Data Engineering"],"content":"4. Routing 模式 Receiving messages selectively (sample code) RabbitMQ - Routing\" RabbitMQ - Routing Routing 模式同樣有一層 Exchange (type=direct)，但不同的是 direct 的特性，Exchange 與 Queue 的綁定(binding)還會帶上 routing key，Producer 傳送訊息到 Exchange 時也會帶上 routing key 這個參數。因此可以達到選擇性訊息分流，不同 Consumer 只需要接受到特定 routing 的訊息。 日誌系統(logging system) RabbitMQ - Logging system\" RabbitMQ - Logging system 上圖為此 日誌系統(logging system) 的範例，使用兩組 Queue： Q1 只有綁定一個 routing key(error)，因此負責寫檔(log file)的 C1 只會接收 error log messages，可節省硬碟(disk)空間。 Q2 則是綁定多個 routing key(info, warning \u0026 error)，負責打印到控制台(console)的 C2 仍然可輸出所有層級(level)的 log messages。 ","date":"2022-03-06","objectID":"/rabbitmq-introduction/:4:4","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式","uri":"/rabbitmq-introduction/"},{"categories":["Data Engineering"],"content":"5. Topics 模式 Receiving messages based on a pattern (sample code) RabbitMQ - Topics\" RabbitMQ - Topics Topics 與 Routing 模式很像，同樣有一層 Exchange (type=topic)，也透過 routing key 來分流訊息，差別在 topic 的特性能夠模糊綁定非固定的 routing key。 設定模糊 routing key 的 patten 必須是以 .(dot) 分隔的字串，*(star) 只能代替一個單詞、#(bash) 可以代替零個或多個單詞。 很難理解對吧XD 我們用上圖作為範例來解釋就會懂了！ 假設我們要發送的是「 描述動物的訊息 」，訊息將使用由三個單詞（包含兩個 .）組成的 routing key 發送，第一個單詞是 “速度”，第二個單詞是 “顏色”，第三個單詞是 “物種”：\u003c速度\u003e.\u003c顏色\u003e.\u003c物種\u003e。 我們將 Exchange 與 Q1 以 .orange. 綁定，與 Q2 以 *.*.rabbit 和 lazy.# 綁定，也就是： Q1 會收到所有關於 “橘色動物” 的訊息 Q2 會收到所有關於 “兔子” 的訊息，以及所有關於 “懶惰動物” 的訊息 以下為 P 傳入的訊息及結果： quick.orange.rabbit 會進入兩個 Queue：Q1 及 Q2 lazy.orange.elephant 會進入兩個 Queue：Q1 及 Q2 quick.orange.fox 會進入一個 Queue：Q1 lazy.brown.fox 會進入一個 Queue：Q2 lazy.pink.rabbit 會進入一個 Queue：Q2（僅一次，即使匹配兩個綁定） quick.brown.fox 不會進入任何 Queue（與任何綁定都不匹配） 再讓我們看一些訊息長度特殊的案例： orange 不會進入任何 Queue（違反 “.orange.”，前後各缺少一個單詞） quick.orange.male.rabbit 不會進入任何 Queue（違反 *.*.rabbit，前後多出一個單詞） lazy.orange.male.rabbit 會進入一個 Queue：Q2（即使它有四個單詞，還是與 lazy.# 匹配） ","date":"2022-03-06","objectID":"/rabbitmq-introduction/:4:5","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式","uri":"/rabbitmq-introduction/"},{"categories":["Data Engineering"],"content":"參考 https://godleon.github.io/blog/ChatOps/message-queue-concepts/ https://kucw.github.io/blog/2020/11/rabbitmq/ https://homuchen.com/posts/message-queue-advantages-use-cases/ https://www.cloudamqp.com/blog/part1-rabbitmq-for-beginners-what-is-rabbitmq.html https://www.cloudamqp.com/docs/amqp.html ","date":"2022-03-06","objectID":"/rabbitmq-introduction/:5:0","tags":["rabbitmq","message-queue"],"title":"[DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式","uri":"/rabbitmq-introduction/"},{"categories":["Data Engineering"],"content":"這陣子團隊在開發相似商品搜尋的 ML Product，為了要把系統架構解耦，改為異步分散式處理，因而接觸到訊息佇列(Message Queue)，作為兩個子系統（商品資料爬蟲 \u0026 圖片/文字向量轉換）的通信中間層。我將透過四篇文章分享我在使用 RabbitMQ 與 Python 實作的學習。","date":"2022-03-03","objectID":"/message-queue-introduction/","tags":["message-queue","system-design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue 介紹與實際應用","uri":"/message-queue-introduction/"},{"categories":["Data Engineering"],"content":"前言 這陣子團隊在開發相似商品搜尋的 ML Product，為了要把系統架構解耦，改為異步分散式處理，因而接觸到訊息佇列(Message Queue)，作為兩個子系統（商品資料處理 \u0026 特徵向量轉換）的通信中間層。我將透過四篇文章分享我在使用 RabbitMQ 與 Python 實作的學習。 [ 系列文章目錄 ] [DATA] 訊息佇列 01 - Message Queue 介紹與實際應用（本篇） [DATA] 訊息佇列 02 - RabbitMQ 簡介與 5 種設計模式 [DATA] 訊息佇列 03 - RabbitMQ 架設方法與網頁管理介面 [DATA] 訊息佇列 04 - RabbitMQ x Python 程式實作範例 ","date":"2022-03-03","objectID":"/message-queue-introduction/:1:0","tags":["message-queue","system-design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue 介紹與實際應用","uri":"/message-queue-introduction/"},{"categories":["Data Engineering"],"content":"什麼是 Message Queue(MQ)？ Message Queue\" Message Queue Message Queue(MQ)是一種訊息傳遞仲介，架構中擁有三個角色，分別為 Producer、Broker 及 Consumer，提供不同程序(process)或不同系統(system)的非同步(asynchronous)溝通。 什麼是非同步呢？ 一般常見的 HTTP API 就屬於同步式方法，發送方(sender) 發出請求(request)，等待接收方(receiver) 處理完回應(response)，等待過程不能斷開連線去做其他事。 Producer：產生 Message 的角色，可能是程式、感測器(sensor)等，負責將訊息傳送給指定的 Broker Broker：就是 Queue 本身（以不同名稱區分)，負責暫存訊息，再依序（先進先出）傳送給 Consumer Consumer：消化 Message 的角色（或稱為 Worker)，負責主動拿取或被動接收 Broker 的訊息 Message：泛指在 Queue 之間流通的訊息（或稱為任務)，包含 routing info（標籤）\u0026 body（內容） 由於先進先出(FIFO)的特性，發送方(producer) 只要把訊息往 MQ(broker) 裡面丟，接收方(consumer) 就能夠依序從 MQ(broker) 中取出訊息，使雙方能夠獨立運作，不需要放在同一套系統內。 ","date":"2022-03-03","objectID":"/message-queue-introduction/:2:0","tags":["message-queue","system-design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue 介紹與實際應用","uri":"/message-queue-introduction/"},{"categories":["Data Engineering"],"content":"使用 Message Queue 有什麼好處？ ","date":"2022-03-03","objectID":"/message-queue-introduction/:3:0","tags":["message-queue","system-design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue 介紹與實際應用","uri":"/message-queue-introduction/"},{"categories":["Data Engineering"],"content":"任務緩衝 短時間內收到大量請求可能會導致系統過載，特別是 CPU / GPU 運算吃重(heavy computing)的情況，這時候 MQ 就發揮了緩衝的功能，Producer 不需等待地向 Broker 發送訊息(任務)；Consumer 依自己的資源和算力從 Broker 取出適量的訊息(任務)，處理完再繼續拿。 ","date":"2022-03-03","objectID":"/message-queue-introduction/:3:1","tags":["message-queue","system-design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue 介紹與實際應用","uri":"/message-queue-introduction/"},{"categories":["Data Engineering"],"content":"暫存容錯 若 Consumer 意外關閉，未處理完的訊息還會存在 MQ 內，並不會丟失，只要再把 Consumer 重啟，又可以接續處理。（通常可設定要暫存或是丟棄） ","date":"2022-03-03","objectID":"/message-queue-introduction/:3:2","tags":["message-queue","system-design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue 介紹與實際應用","uri":"/message-queue-introduction/"},{"categories":["Data Engineering"],"content":"系統解耦 架構設計上拆分為不同元件(components)獨立開發，Producer、Broker 及 Consumer 不需部署在同一台機主機，不需知道彼此的 IP address，也不需使用相同的程式語言。 ","date":"2022-03-03","objectID":"/message-queue-introduction/:3:3","tags":["message-queue","system-design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue 介紹與實際應用","uri":"/message-queue-introduction/"},{"categories":["Data Engineering"],"content":"水平擴展 Message Queue - multi\" Message Queue - multi Producer 可分散在不同來源、裝置收集（e.g. IoT applications）；Consumer 可以按照需求和資源，運行在多台機器上，加速訊息(任務)的消化和處理。 ","date":"2022-03-03","objectID":"/message-queue-introduction/:3:4","tags":["message-queue","system-design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue 介紹與實際應用","uri":"/message-queue-introduction/"},{"categories":["Data Engineering"],"content":"常見工具 Message Queue - Products\" Message Queue - Products Message Queue 常見的開源工具有 RabbitMQ、Redis、Kafka（不同特性可參考 這篇）。 雲端服務則是像是 GCP 的 Cloud Pub/Sub 和 AWS 的 Amazon SQS。 RabbitMQ 下一篇文章，我將介紹目前團隊所使用的 RabbitMQ 有哪些優勢、設計模式、架設方法等等。 ","date":"2022-03-03","objectID":"/message-queue-introduction/:4:0","tags":["message-queue","system-design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue 介紹與實際應用","uri":"/message-queue-introduction/"},{"categories":["Data Engineering"],"content":"實際應用 這是某相似商品比對產品的 ETL 架構圖（擷取簡化部分），任務是每天將商品資訊（圖片 \u0026 文字）進行向量轉換，\u0008分為會使用到 CV 模型和 NLP 模型，由於 GPU 運算負擔比較重（機器資源、計算時間等），因此將系統拆分為下圖左邊紅底的 Producer 和右邊藍底的 Consumer。 案例架構圖\" 案例架構圖 Producer 負責資料過濾(data filtering)特徵提取(feature extraction)；Consumer 負責任務收集(task collecting)和向量轉換(vectorization)。兩個系統彼此不會直接溝通，而是將 Message 透過 Broker 暫存與傳遞，分為 Image Queue 和 Text Queue，\u0008\u0008並可以根據目標完成時間來調整 Producer 和 Consumer 的數量，加速任務的消化。 這樣的設計相對過去採用 HTTP 連線效率提高（不需互相等待）；部署在不同規格的機器(VM)，Producer 選用低規格的機器，Consumer 選用搭載 GPU 的機器，也可以大大地降低成本。 ","date":"2022-03-03","objectID":"/message-queue-introduction/:5:0","tags":["message-queue","system-design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue 介紹與實際應用","uri":"/message-queue-introduction/"},{"categories":["Data Engineering"],"content":"參考 https://homuchen.com/posts/message-queue-advantages-use-cases/ https://godleon.github.io/blog/ChatOps/message-queue-concepts/ ","date":"2022-03-03","objectID":"/message-queue-introduction/:6:0","tags":["message-queue","system-design","architecture"],"title":"[DATA] 訊息佇列 01 - Message Queue 介紹與實際應用","uri":"/message-queue-introduction/"},{"categories":["DevOps"],"content":"自從去年初啟動“敏捷”(Scrum)導入，幾乎都在適應(迭代)各種流程、方法和工具，工程實踐方面的單元測試和 CI/CD 推行計畫卻一直往後延。如今，因應團隊一個大型系統要進行前後端分離重構，加上大家對於容器化技術越來越熟悉，同時又有優秀的新夥伴加入，可謂是天時地利人和啊，我們終於要啟動 CI/CD 導入！","date":"2022-02-13","objectID":"/cicd-introduction/","tags":["cicd","devops"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-introduction/"},{"categories":["DevOps"],"content":"前言 自從去年初啟動“敏捷”(Scrum)導入，幾乎都在適應(迭代)各種流程、方法和工具，工程實踐方面的單元測試和 CI/CD 推行計畫卻一直往後延。如今，因應團隊一個大型系統要進行前後端分離重構，加上大家對於容器化技術越來越熟悉，同時又有優秀的新夥伴加入，可謂是天時地利人和啊，我們終於要開始在“開發”上實踐敏捷，啟動 CI/CD 導入！ 這此之前我對 CI/CD 的理解幾乎是一片空白，因此想利用這篇文章，記錄過程中的學習心得與知識整理。首先將介紹「什麼是 CI/CD？」、「為什麼要 CI/CD？」、「CI/CD 如何做？」以及「常見的 CI/CD 工具」，您可以透過右側選單快速跳轉至感興趣的章節。內容會比較初淺，請小心服用。 歡迎給予任何反饋和指正～ ","date":"2022-02-13","objectID":"/cicd-introduction/:1:0","tags":["cicd","devops"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-introduction/"},{"categories":["DevOps"],"content":"什麼是 CI/CD？ CI/CD cycleCI/CD cycle \" CI/CD cycle 敏捷式軟體開發生命週期中，從開發、測試到部署是一系列持續迭代的過程，CI/CD 指的是持續整合和持續交付或持續部署的組合實踐。CI/CD通過在應用程式的構建、測試和部署中實施自動化，在開發和運營團隊之間架起了橋梁。 ","date":"2022-02-13","objectID":"/cicd-introduction/:2:0","tags":["cicd","devops"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-introduction/"},{"categories":["DevOps"],"content":"CI 持續整合 (Continuous Integration) 每當開發人員 push 程式碼變更到 remote repository 時，觸發自動化 build 和 test 的程序，確保這次的變更是符合規範且通過所有測試案例的，減少有問題的程式碼影響到生產環境的機會。 ","date":"2022-02-13","objectID":"/cicd-introduction/:2:1","tags":["cicd","devops"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-introduction/"},{"categories":["DevOps"],"content":"CD 持續交付 / 持續部署 (Continuous Delivery / Continuous Deployment) 完成 Build 和 Test 的下一步就是程式碼部署啦，而 Continuous Delivery 和 Continuous Deployment 的差別就是人為手動部署和自動化部署而已。 ","date":"2022-02-13","objectID":"/cicd-introduction/:2:2","tags":["cicd","devops"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-introduction/"},{"categories":["DevOps"],"content":"CI/CD Workflow CI/CD WorkflowCI/CD Workflow \" CI/CD Workflow 從上面這張流程圖的可以看出 CI/CD 主要的工作流：(1)當專案程式碼提交 (commit → push / merge)；(2)進入 CI Pipeline，建立一個測試環境，跑過所有單元測試+整合測試、程式碼規範檢查；(3)進入 CD Pipeline，完成程式碼部署。 CI/CD = 自動化測試 + 自動部署？ 看完前面的介紹，可能會認為 CI/CD 只是寫腳本跑自動化測試 + 自動部署，然而 “Continuous” 的意義是“頻繁地”釋出新版本，降低過大變動帶來的問題與衝突，從 3 個月發佈 1 次，到 1 天發佈 3 次，達到敏捷精神中小步快跑、快速迭代的狀態。 ","date":"2022-02-13","objectID":"/cicd-introduction/:2:3","tags":["cicd","devops"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-introduction/"},{"categories":["DevOps"],"content":"為什麼要 CI/CD？ 想像一下，上述流程若都交給開發人員手動執行，不僅要花大量操作時間和等待時間，還可能會有人為失誤產生，更何況 CI/CD 要我們頻繁做這些事，導致成本大幅增加。 ","date":"2022-02-13","objectID":"/cicd-introduction/:3:0","tags":["cicd","devops"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-introduction/"},{"categories":["DevOps"],"content":"CD/CD 的好處 Happiness for Developer (https://stackoverflow.blog/2020/02/27/the-eight-factors-of-happiness-for-developers/)Happiness for Developer \" Happiness for Developer (https://stackoverflow.blog/2020/02/27/the-eight-factors-of-happiness-for-developers/) CI/CD 可以為團隊帶來以下好處，同時也是我們所追求的目標： 避免版本衝突 降低人為操作失誤 減少人工時間花費 及早發現(bug)及早修正(fix) 專注開發提高生產力 加速產品迭代 延伸思考 這些目標其實都不太具體，還需要進一步透過量化指標來評估 CI/CD 成效，有興趣的朋友可參考這篇 衡量和監控 CI/CD 性能。 ","date":"2022-02-13","objectID":"/cicd-introduction/:3:1","tags":["cicd","devops"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-introduction/"},{"categories":["DevOps"],"content":"CI/CD 如何做？ 為了達到快速又頻繁的新版本發佈，必須要有嚴謹和穩健的流程，從前面的 CI/CD Workflow 可見步驟相當繁瑣且有相依性，因此需要透過工具和指令，有效地自動化幫我們執行這些程序。 ","date":"2022-02-13","objectID":"/cicd-introduction/:4:0","tags":["cicd","devops"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-introduction/"},{"categories":["DevOps"],"content":"先備知識與技能 做 CI/CD 之前，建議團隊要有一定的成熟度，才能快速將現有的程序轉換為自動化的方式運行，以下是我認為必須先具備的知識和技能，導入 CI/CD 時較能快速上手： Shell Script(Command)：與作業系統 Kernel 互動的語言(指令)是一切的基礎 SSH 連線：創建公鑰和私鑰，以特定使用者連線至遠端 Server 進行操作 Git 版本控制：任何一種 Git workflow，用來管理分支、切換版本、合併流程 容器化技術：用來隔離環境，快速搭建和部署（e.g. docker, docker-compose) 程式碼規範檢查：檢查你的程式碼，是否符合團隊規範的程式碼風格 單元測試、整合測試、自動化測試：檢查你的程式碼，能否在目標環境正常運作 ","date":"2022-02-13","objectID":"/cicd-introduction/:4:1","tags":["cicd","devops"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-introduction/"},{"categories":["DevOps"],"content":"流程與準備 上述的知識與技能你都已經掌握了之後，開始盤點 CI/CD 各個步驟會用到的指令，接著確認這些指令的順序（哪些具有相依性？哪些可以平行化？） GitLab CI/CD Pipeline(source: https://docs.gitlab.com/ee/ci/pipelines/)\" GitLab CI/CD Pipeline(source: https://docs.gitlab.com/ee/ci/pipelines/) 小建議 先將工作流程的 DAG (Directed Acyclic Graph，有向無環圖)畫出來，然後手動執行一遍所有流程（這時有就能感受到人工做這些事其實相當繁瑣及耗時），下一步就是將相同的程序透過工具自動化執行啦！ ","date":"2022-02-13","objectID":"/cicd-introduction/:4:2","tags":["cicd","devops"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-introduction/"},{"categories":["DevOps"],"content":"CI/CD 工具 常見的 CI/CD 工具有 Jenkins、GitLab、Circle CI、Travis CI、Drone 等，另外，各大雲端平台(AWS, GCP, Azure)也有推出 CI/CD 解決方案，更好地整合了自家的雲端服務。 Continuous delivery tool landscape(source: http://www.jamesbowman.me/post/continuous-delivery-tool-landscape/Continuous delivery tool landscape \" Continuous delivery tool landscape(source: http://www.jamesbowman.me/post/continuous-delivery-tool-landscape/ 一般我們會希望這些工具通常具備以下功能： 最基本的建立、編輯腳本 相容各 Git 程式碼託管平台 視覺化呈現工作流(Workflow)、狀態(Status)和進度(Progress) 管理不同使用者權限(Maintainer, Developer, Reviewer, etc.) 可將任務分散給多個 Runner / Worker 執行 設定成功 / 失敗發送信件通知 支持第三方工具整合 … Info 我目前團隊用的程式碼託管平台是 GitLab，評估過後發現 GitLab 的 CI/CD 解決方案很棒，因此選用為我們的工具，並開始逐步導入。（之後文章將會介紹使用方式） ","date":"2022-02-13","objectID":"/cicd-introduction/:4:3","tags":["cicd","devops"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-introduction/"},{"categories":["DevOps"],"content":"總結 好的 CI/CD 可以幫助團隊減少人為失誤，提高生產力，加速產品迭代；壞的 CI/CD 可能會導致流程更加混亂，增加人力除錯成本，造成品質低落。 所以你應該依團隊目前的成熟度，逐步將 CI/CD 各個環節添加進去，不需要一次就全部導入，例如：單元測試尚未落實的團隊，進入 CI 階段前可以先透過 Code Review 檢查；自動部署尚未穩定的團隊，CD 階段可以只做到自動交付，保留最後一步由人工進行部署。 最後，期望團隊今年可以在各大專案中導入，也期許自己保有持續輸出(Continuous Output)、持續分享(Continuous Sharing)的精神XD ","date":"2022-02-13","objectID":"/cicd-introduction/:5:0","tags":["cicd","devops"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-introduction/"},{"categories":["DevOps"],"content":"參考 https://docs.gitlab.com/ee/ci/ https://www.redhat.com/zh/topics/devops/what-is-ci-cd https://bear-1111.medium.com/什麼是-ci-cd-72bd5ae571f1 https://blog.kennycoder.io/2020/04/07/CI-CD-持續性整合-部署-因為懶，所以更要CI-CD！概念講解！/ ","date":"2022-02-13","objectID":"/cicd-introduction/:6:0","tags":["cicd","devops"],"title":"[DevOps] CI/CD 介紹 - 基礎概念與導入準備","uri":"/cicd-introduction/"},{"categories":null,"content":"Works a b c ","date":"2021-10-26","objectID":"/cv/:0:1","tags":null,"title":"CV","uri":"/cv/"},{"categories":null,"content":"Education a b c ","date":"2021-10-26","objectID":"/cv/:0:2","tags":null,"title":"CV","uri":"/cv/"},{"categories":null,"content":"Talks a b c ","date":"2021-10-26","objectID":"/cv/:0:3","tags":null,"title":"CV","uri":"/cv/"},{"categories":null,"content":"Skills a b c ","date":"2021-10-26","objectID":"/cv/:0:4","tags":null,"title":"CV","uri":"/cv/"},{"categories":null,"content":"Special a b c ","date":"2021-10-26","objectID":"/cv/:0:5","tags":null,"title":"CV","uri":"/cv/"},{"categories":null,"content":"Hello 我是 Enzo，一位非典型工程師，跨足資料科學 x 軟體開發 x 資訊教育，熱愛學習與參加社群，目前在某電商平台擔任 Data Engineer (90%)，身兼 Scrum Master (10%)。曾經在接案公司擔任軟體工程師和專案經理，經歷各種隕石需求和合約戰爭荼毒，遇見敏捷(Agile/Scrum)後，深受其價值觀所吸引，致力成為身心合一的敏捷實踐家！ ","date":"2021-10-26","objectID":"/about/:0:1","tags":null,"title":"關於本站","uri":"/about/"},{"categories":null,"content":"架站動機 架設這個部落格的目的是想記錄自己在工作上或日常中的成長歷程，因為我認為學習必須經過自己的整理和輸出，梳理自己對於知識概念的，形成自己的觀點。過去我雖然有在社群媒體發文，但其觸及率極低且無法被搜尋引擎找到，因此，想要建立這個專屬的空間，集中並擴大影響力。 ","date":"2021-10-26","objectID":"/about/:0:2","tags":null,"title":"關於本站","uri":"/about/"},{"categories":null,"content":"文章方向 這個部落格的文章主題會以「 資料工程 Data Engineering 」、「 敏捷 Agile/Scrum 」、「 職涯探索 Career」為主，內容類型可能為學習筆記、實作教學、經驗分享、個人觀點等。 ","date":"2021-10-26","objectID":"/about/:0:3","tags":null,"title":"關於本站","uri":"/about/"},{"categories":null,"content":"行動期許 期許自己能夠堅持寫文，幫助自己也能幫助到別人，也歡迎你與我連結、互相交流。 ","date":"2021-10-26","objectID":"/about/:0:4","tags":null,"title":"關於本站","uri":"/about/"},{"categories":null,"content":"聯繫方式 Facebook：https://www.facebook.com/enzoapu Linkedin：https://www.linkedin.com/in/enzochang E-mail：enzoapu@gmail.com PyData Taipei 2020https://pydata.org/taipei2020/program/talk-14/ \" PyData Taipei 2020 ","date":"2021-10-26","objectID":"/about/:0:5","tags":null,"title":"關於本站","uri":"/about/"}]